<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Linux ARM Template UI</title>
  <style>
    :root {
      --bg: #ffffff;
      --card: #ffffff;
      --border: #edebe9;
      --text: #201f1e;
      --muted: #605e5c;
      --primary: #0078d4;
      --danger: #b91c1c;
      --headerBg: #0078d4;
      --headerText: #ffffff;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: var(--sans); color: var(--text); background: var(--bg); }
    header { background: var(--headerBg); color: var(--headerText); padding: 12px 16px; font-weight: 800; box-shadow: inset 0 -1px 0 rgba(255,255,255,0.18); display: flex; align-items: center; justify-content: space-between; gap: 12px; }
    .container { padding: 16px; max-width: 1500px; margin: 0 auto; }
    .hint { color: var(--muted); margin: 8px 0 16px; font-size: 14px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 1100px) { .grid { grid-template-columns: 1fr 1fr; } }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 10px; padding: 12px; box-shadow: 0 1px 2px rgba(0,0,0,0.04); min-height: 420px; min-width: 0; }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 8px; flex-wrap: wrap; }
    .title { font-size: 16px; font-weight: 900; }
    .actions { display: flex; gap: 8px; flex-wrap: wrap; }
    #outputActions { position: relative; display: flex; align-items: center; gap: 0; flex-wrap: wrap; }
    .btn-group { display: flex; gap: 0; }
    .btn-group button { border-radius: 0; margin: 0; border-right-width: 0; }
    .btn-group button:first-child { border-radius: 8px 0 0 8px; }
    .btn-group button:last-child { border-radius: 0 8px 8px 0; border-right-width: 1px; }
    .btn-group button:only-child { border-radius: 8px; border-right-width: 1px; }
    .btn-divider { width: 1px; height: 24px; background: var(--border); margin: 0 10px; flex-shrink: 0; }

    button { border: 1px solid var(--border); background: #fff; padding: 8px 10px; border-radius: 8px; cursor: pointer; font-weight: 800; }
    button.primary { background: var(--primary); color: #fff; border-color: var(--primary); }
    button.danger { background: #fff; border-color: #f0b4b4; color: var(--danger); }
    button:disabled { opacity: 0.55; cursor: not-allowed; }

    .tabs { display: flex; gap: 6px; padding: 10px 0 8px; overflow-x: auto; overflow-y: hidden; max-width: 100%; border-bottom: 1px solid var(--border); margin-top: 10px; }
    .tab { flex: 0 0 auto; white-space: nowrap; border: 1px solid var(--border); border-radius: 999px; padding: 6px 10px; font-weight: 900; font-size: 13px; background: #fff; }
    .tab.active { border-color: var(--primary); color: var(--primary); background: #eef2ff; }

    .form { padding-top: 12px; display: grid; grid-template-columns: 1fr; gap: 10px; }
    @media (min-width: 720px) { .form.two { grid-template-columns: 1fr 1fr; } }

    label { font-size: 12px; color: var(--muted); font-weight: 900; display: block; margin-bottom: 6px; }
    input, select, textarea { width: 100%; border: 1px solid var(--border); border-radius: 8px; padding: 10px; font-size: 14px; background: #fff; }
    textarea { font-family: var(--mono); font-size: 12px; line-height: 1.35; resize: vertical; min-height: 340px; }

    .section { margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border); }
    .section h3 { margin: 0; font-size: 14px; }

    .box { border: 1px solid var(--border); border-radius: 10px; padding: 10px; margin-top: 8px; background: #fff; }

    .grid3 { display: grid; grid-template-columns: 1fr; gap: 8px; align-items: end; }
    @media (min-width: 720px) { .grid3 { grid-template-columns: 1fr 1fr auto; } }

    .muted { color: var(--muted); font-size: 13px; margin-top: 8px; }
    .error-text { color: var(--danger); font-size: 12px; margin-top: 6px; font-weight: 700; }
    .pill { display: inline-block; font-size: 12px; font-weight: 900; padding: 2px 8px; border-radius: 999px; border: 1px solid var(--border); color: #111; background: #f7f7f7; }
    .warn { border-color: #f3d08b; background: #fff7e6; }
    .ok { border-color: #b7e3c4; background: #ecfdf3; }

    .toggle { display: inline-flex; align-items: center; gap: 8px; }
    .toggle input[type="checkbox"] { width: 18px; height: 18px; margin: 0; }

    table.summary { width: 100%; border-collapse: collapse; margin-top: 8px; font-size: 12px; table-layout: fixed; }
    table.summary th, table.summary td { border: 1px solid var(--border); padding: 6px 8px; text-align: left; vertical-align: top; }
    table.summary th { background: #f8f8f8; font-weight: 900; }
    .truncate-cell { display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    #vmCustomData { min-height: 96px; font-family: var(--mono); font-size: 12px; }
    .help-wrap { position: relative; }
    .help-balloon {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      width: min(520px, 90vw);
      background: #ffffff;
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      padding: 12px;
      z-index: 30;
      color: var(--text);
      font-size: 13px;
      line-height: 1.45;
      display: none;
      white-space: normal;
    }
    .help-balloon.show { display: block; }
    .help-balloon { font-weight: 400; }
    .help-balloon h4 { margin: 0 0 8px; font-size: 14px; font-weight: 700; }
    .help-balloon ul { margin: 0 0 0 16px; padding: 0; }
    .help-balloon li { margin: 4px 0; }
    #helpBtn { border-color: rgba(255,255,255,0.45); background: rgba(255,255,255,0.14); color: #fff; }
    #helpBtn:hover { background: rgba(255,255,255,0.22); }
    .test-btn { padding: 0; border: 0; background: transparent; line-height: 0; }
    .test-btn img { height: 28px; width: auto; display: block; border-radius: 4px; }

    code.inline { font-family: var(--mono); font-size: 12px; background: #f3f4f6; padding: 2px 6px; border-radius: 6px; border: 1px solid #e5e7eb; }
  
 /* Toast */
 .toast {position: fixed; right: 16px; bottom: 16px; max-width: 520px; padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border); background: #111827; color: #fff; box-shadow: 0 10px 25px rgba(0,0,0,0.18); font-size: 13px; line-height: 1.35; opacity: 0; transform: translateY(10px); pointer-events: none; transition: opacity .18s ease, transform .18s ease; z-index: 9999;}
 .toast.show {opacity: 1; transform: translateY(0);}
 .toast .title {font-size: 13px; font-weight: 900; margin-bottom: 2px;}
 .toast .msg {color: #e5e7eb;}

 /* Screen-reader-only (visually hidden, announced by assistive tech) */
 .sr-only {position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0;}

 .deploy-flow-inline {position: absolute; top: calc(100% + 8px); right: 0; width: min(560px, 92vw); display: none; padding: 8px 10px; border-radius: 8px; border: 1px solid #f3d08b; background: #fff7e6; color: #3f3f46; font-size: 12px; line-height: 1.35; box-shadow: 0 10px 24px rgba(0,0,0,0.14); z-index: 10001; pointer-events: none;}
 .deploy-flow-inline.show {display: block;}
 .deploy-flow-inline .title {font-size: 12px; font-weight: 900; margin-bottom: 2px; color: #201f1e;}
 .deploy-flow-inline .msg {color: #3f3f46;}

 .size-filter-wrap { position: relative; font-size: 12px; }
 .size-filter-toolbar { display: flex; flex-wrap: wrap; align-items: center; gap: 10px; justify-content: space-between; }
 .size-filter-actions { display: inline-flex; gap: 8px; align-items: center; }
 .size-filter-actions button { font-size: 12px; font-weight: 700; padding: 6px 9px; }
 .size-filter-chips { display: inline-flex; flex-wrap: wrap; gap: 6px; min-height: 34px; align-items: center; justify-content: flex-end; margin-left: auto; }
 .chip-btn { border: 1px solid #c9d8e6; border-radius: 999px; padding: 5px 9px; background: #e8f0f8; color: #1f2937; font-size: 11px; font-weight: 700; display: inline-flex; align-items: center; gap: 6px; }
 .chip-btn .x { font-weight: 900; color: #6b7280; }
 .size-filter-panel { position: absolute; top: calc(100% + 8px); right: 0; width: min(680px, 95vw); border: 1px solid var(--border); border-radius: 10px; padding: 14px; background: #fff; box-shadow: 0 12px 28px rgba(0,0,0,0.16); z-index: 40; }
 .size-filter-panel-grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
 @media (min-width: 900px) { .size-filter-panel-grid { grid-template-columns: 1fr 1fr; } }
 .size-filter-item label { margin-bottom: 4px; font-size: 11px; }
 .size-filter-item select { width: 100%; font-size: 12px; padding: 7px 8px; }
 .size-filter-panel-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 10px; }
 .size-filter-panel-actions button { font-size: 12px; font-weight: 700; padding: 6px 9px; }
 .size-filter-panel-title { font-weight: 700; font-size: 12px; margin-bottom: 8px; color: var(--muted); }
</style>
</head>
<body>
  <header>
    <div>Linux - ARM Template UI</div>
    <div class="help-wrap">
      <button id="helpBtn" type="button">Help</button>
      <div id="helpBalloon" class="help-balloon" role="dialog" aria-label="Help" aria-hidden="true">
        <h4>How this template builder works</h4>
        <ul>
          <li><strong>VMs:</strong> Create one or more VMs. Each has a size, generation, architecture, image, disk controller, NICs, and optional data disks.</li>
          <li><strong>Image filtering:</strong> The image list is filtered by selected generation, architecture, controller type, and optional publisher filter. Incompatible choices are auto-corrected with a toast notification.</li>
          <li><strong>Size filters:</strong> Use the multi-filter panel to narrow VM sizes by family, architecture, generation, controller, disk SKU, accelerated networking, ephemeral disk support, min NICs, or min data disks. Active filters show as removable chips.</li>
          <li><strong>NIC policy:</strong> Accelerated networking is enforced per size (required / optional / unsupported). NIC and data disk counts are capped by size limits.</li>
          <li><strong>Data disks:</strong> SKU options are restricted to SKUs supported by the selected VM size. Disk size limits are enforced per SKU.</li>
          <li><strong>Validation:</strong> VM names and NIC names must be valid, unique, and within Azure resource name length limits before JSON can be exported.</li>
          <li><strong>Output:</strong> Generated ARM includes a shared VNet/subnet/NSG, plus per-VM NICs, optional public IPs, and VM resources. Ultra SSD disks trigger zonal placement.</li>
          <li><strong>Custom data:</strong> Optional. When present, it is directly base64-encoded into ARM customData.</li>
          <li><strong>Import JSON:</strong> Import a previously generated (or compatible) ARM template to re-populate the tool. VMs whose size or image is not in the catalog are skipped with a summary toast. Custom data cannot be reverse-decoded and is cleared on import.</li>
          <li><strong>Persistence:</strong> Your VM configuration and active filters are auto-saved to localStorage and restored on page reload.</li>
          <li><strong>Keyboard:</strong> VM tabs support arrow-key navigation. The filter panel traps focus and closes with Escape. Screen reader announcements report filter result counts.</li>
        </ul>
      </div>
    </div>
  </header>

  <div class="container">
    <div class="grid">
      <!-- Left -->
      <div class="card">
        <div class="row">
          <div class="title">VMs</div>
          <div class="actions">
            <div class="btn-group">
              <button class="primary" id="addVmBtn">Add VM</button>
              <button id="cloneVmBtn">Clone VM</button>
            </div>
            <button class="danger" id="removeVmBtn">Remove VM</button>
          </div>
        </div>

        <div class="tabs" id="tabs" role="tablist" aria-label="VM tabs"></div>

        <div class="section">
          <div class="row">
            <h3>VM Settings</h3>
            <span class="muted" id="vmMeta"></span>
          </div>

          <div class="form two">
            <div>
              <label for="vmName">VM Name</label>
              <input id="vmName" placeholder="vm1" />
              <div id="vmNameError" class="error-text"></div>
            </div>

            <div>
              <label for="vmSize">VM Size</label>
              <select id="vmSize"></select>
              <div class="muted" id="sizeHint"></div>
            </div>

            <div style="grid-column: 1 / -1;">
              <div class="size-filter-wrap">
                <div class="size-filter-toolbar">
                  <div class="size-filter-actions">
                    <button id="addSizeFilterBtn" type="button">+ Add VM filter</button>
                    <button id="clearSizeFiltersBtn" type="button">Clear</button>
                  </div>
                  <div id="sizeFilterChips" class="size-filter-chips"></div>
                </div>
                <div id="sizeFilterPanel" class="size-filter-panel" role="dialog" aria-modal="true" aria-label="VM size filters" style="display:none;">
                  <div class="size-filter-panel-title">Set VM size filters</div>
                  <div id="sizeFilterGrid" class="size-filter-panel-grid"></div>
                  <div class="size-filter-panel-actions">
                    <button id="sizeFilterOkBtn" type="button" class="primary">OK</button>
                    <button id="sizeFilterCancelBtn" type="button">Cancel</button>
                  </div>
                </div>
              </div>
              <div id="sizeFilterLive" class="sr-only" aria-live="polite" aria-atomic="true"></div>
            </div>

            <div>
              <label for="vmGen">VM Generation (constrained by size)</label>
              <select id="vmGen"></select>
            </div>

            <div>
              <label for="vmPublisher">Publisher</label>
              <select id="vmPublisher"></select>
            </div>

            <div>
              <label for="vmImage">OS Image (filtered by size tags)</label>
              <select id="vmImage"></select>
              <div class="muted" id="imageHint"></div>
            </div>

            <div>
              <label for="diskController">Disk Controller Type (constrained by size)</label>
              <select id="diskController"></select>
            </div>

            <div style="grid-column: 1 / -1;">
              <label for="vmCustomData">Custom Data (optional)</label>
              <textarea id="vmCustomData" placeholder="#cloud-config&#10;package_update: true"></textarea>
              <div class="toggle" style="margin-top: 8px;">
                <input id="vmRebootRequired" type="checkbox" />
                <span class="muted" style="margin-top: 0;">Reboot required after deployment</span>
              </div>
            </div>
          </div>
        </div>

        <div class="section">
          <div class="row">
            <h3>Network Interfaces (NICs)</h3>
            <button id="addNicBtn">Add NIC</button>
          </div>
          <div id="nicList"></div>
          <div class="muted" id="noNicMsg">No NICs (a VM requires at least one NIC). This page will auto-create one if missing.</div>
        </div>

        <div class="section">
          <div class="row">
            <h3>Data Disks</h3>
            <button id="addDiskBtn">Add disk</button>
          </div>
          <div id="diskList"></div>
          <div class="muted" id="noDiskMsg">No data disks.</div>
        </div>

      </div>

      <!-- Right -->
      <div class="card">
        <div class="row">
          <div class="title">Generated ARM JSON</div>
          <div class="actions" id="outputActions">
            <div class="btn-group">
              <button id="copyBtn">Copy</button>
              <button id="deployPortalBtn">Copy + Portal</button>
              <button class="primary" id="downloadBtn">Download</button>
            </div>
            <div class="btn-divider"></div>
            <button id="importBtn" title="Import an ARM template JSON to populate the tool">Import JSON</button>
            <input type="file" id="importFileInput" accept=".json,application/json" style="display:none;" />
            <div id="deployFlowInline" class="deploy-flow-inline" aria-live="polite" aria-atomic="true">
              <div class="title" id="deployFlowInlineTitle"></div>
              <div class="msg" id="deployFlowInlineMsg"></div>
            </div>
          </div>
        </div>
        <div class="hint" style="margin: 10px 0 10px;">
          This generates one shared network (VNet, subnet, and NSG), plus each VM with its own NICs. If a VM size does not support accelerated networking, it is turned off automatically.
        </div>

        <textarea id="output" readonly spellcheck="false"></textarea>

        <div class="section" style="margin-top: 10px;">
          <h3>VM Configuration Summary</h3>
          <div id="vmSummary" class="box"></div>
        </div>
      </div>
    </div>
  </div>

<script>
  /*
   * =============================================================================
   * ARM Builder UI - Maintenance Guide
   * =============================================================================
   * Purpose
   *   Build a multi-VM ARM template from a constrained UI model.
   *
   * High-level flow
   *   1) Static catalogs define capabilities:
   *      - imageOptions: OS image compatibility metadata (validated at startup)
   *      - sizeOptions: VM SKU capabilities (validated at startup)
   *   2) User edits active VM in the form.
   *   3) sanitizeAllVms() enforces constraints and auto-corrects invalid choices.
   *   4) updateOutput() regenerates ARM JSON + summary table.
   *   5) Copy/Download/Import exports or imports the generated template.
   *
   * Architecture notes
   *   - Global state is centralized in the `state` object with globalThis
   *     property accessors for backward compatibility (vms, active, sizeFilters).
   *   - UI state (VMs, filters, active tab) persists to localStorage under
   *     UI_STATE_STORAGE_KEY and is restored on page load via loadUiState().
   *   - Named constants live in the frozen LIMITS object (VM name length,
   *     Azure resource name limits, toast durations, default disk size, etc.).
   *   - Per-cycle caches (state._imageCache, state._dupVmNamesCache) avoid
   *     redundant computation within a single render/updateOutput cycle.
   *     Caches are invalidated by invalidateCycleCaches() at the start of
   *     render() and updateOutput().
   *
   * Render pipeline
   *   - render() is the full UI rebuild (tabs, selects, NICs, disks, hints).
   *     Used for tab switches, add/remove/clone VM, filter changes, initial load.
   *   - Targeted helpers avoid full DOM teardown for common interactions:
   *     - renderVmFormFields(vm): updates form field values (no DOM creation).
   *     - renderVmSelects(vm): repopulates gen/controller/publisher/image selects.
   *     - updateNicDiskButtons(vm): refreshes Add NIC / Add Disk disabled state.
   *     - updateNicNameConstraints(vm): patches NIC maxLength + errors in-place.
   *   - Event handlers call the minimum set of helpers needed for each action.
   *
   * Import
   *   - importFromArmJson() parses an ARM template, matches VM sizes and images
   *     to the catalogs, and builds VM models. Unrecognized sizes/images are
   *     skipped. Custom data is cleared on import.
   *
   * Accessibility
   *   - VM tab bar: role="tablist" + role="tab" + aria-selected + arrow keys.
   *   - Filter panel: role="dialog" + aria-modal + focus trap + Escape to close.
   *   - Filter results: aria-live region announces matching size count.
   *   - .sr-only class for visually hidden screen-reader content.
   *
   * Core invariants
   *   - VM names must be valid + unique.
   *   - Selected image must match VM size architecture + generation + controller.
   *   - Data disk SKUs must be supported by selected VM size.
   *   - Accelerated networking follows size policy (required/optional/unsupported).
   *   - Ultra disks trigger zonal placement + ultraSSDEnabled in generated ARM.
   *
   * Recommended maintenance workflow
   *   - Update imageOptions/sizeOptions from validated CLI output.
   *   - Keep keys stable for compatibility with saved configurations.
   *   - Verify UI behavior by changing size/gen/controller and observing auto-fixes.
   *   - After adding new images/sizes, run startup validation (page load checks).
   * =============================================================================
   */

  // ---------------------------------------------------------------------------
  // Utility helpers (ID generation, text encoding, customData conversion)
  // ---------------------------------------------------------------------------
  function uid() { return Math.random().toString(16).slice(2); }

  function toBase64Utf8(text) {
    const bytes = new TextEncoder().encode(String(text || ''));
    let binary = '';
    for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  function encodeCustomDataForArm(text, rebootRequired) {
    const raw = String(text || '').replace(/\r\n/g, '\n');
    if (!raw.trim()) return '';

    const payload = rebootRequired ? `${raw}\n\nsleep 60 && reboot &` : raw;
    return toBase64Utf8(payload);
  }

// ---------------------------------------------------------------------------
// UI feedback helper (small transient notifications for auto-fixes)
// ---------------------------------------------------------------------------
const UI_STATE_STORAGE_KEY = 'armBuilderUiStateV1';

// ---------------------------------------------------------------------------
// Named limits & magic-number constants (single source of truth)
// ---------------------------------------------------------------------------
const LIMITS = Object.freeze({
  VM_NAME_MAX_LEN:          64,   // Azure VM name character limit
  AZ_NETWORK_NAME_MAX_LEN:  80,   // Azure NIC / PIP resource name limit
  DEFAULT_DATA_DISK_GB:     128,  // Default size when adding a new data disk
  FALLBACK_MAX_DISK_GB:     32767,// Fallback max disk size (GiB) when SKU is unknown
  TOAST_DURATION_MS:        2600, // How long a toast notification stays visible
  COPY_FEEDBACK_MS:         900,  // How long "Copied!" label shows on the copy button
  DEPLOY_COUNTDOWN_S:       5,    // Seconds before auto-opening Azure portal
});

const state = {
  timers: {
    toast: null,
    deployFlow: null,
    deployFlowTick: null
  },
  sizeFilters: null,
  vms: null,
  activeVmIndex: 0,
  // Per-cycle caches (invalidated at the start of each render/updateOutput cycle)
  _imageCache: null,
  _dupVmNamesCache: null
};

function showToast(title, msg) {
  const t = document.getElementById('toast');
  const tt = document.getElementById('toastTitle');
  const tm = document.getElementById('toastMsg');
  if (!t || !tt || !tm) return;
  tt.textContent = title || '';
  tm.textContent = msg || '';
  t.classList.add('show');
  if (state.timers.toast) clearTimeout(state.timers.toast);
  state.timers.toast = setTimeout(() => t.classList.remove('show'), LIMITS.TOAST_DURATION_MS);
}

function showDeployFlow(msg, seconds) {
  const panel = document.getElementById('deployFlowInline');
  const title = document.getElementById('deployFlowInlineTitle');
  const body = document.getElementById('deployFlowInlineMsg');
  if (!panel || !title || !body) return;

  let remaining = Math.max(1, Number(seconds || LIMITS.DEPLOY_COUNTDOWN_S));
  title.textContent = `Warning: opening Azure portal in ${remaining}s`;
  body.textContent = msg || '';
  panel.classList.add('show');

  if (state.timers.deployFlowTick) clearInterval(state.timers.deployFlowTick);
  state.timers.deployFlowTick = setInterval(() => {
    remaining -= 1;
    if (remaining <= 0) {
      clearInterval(state.timers.deployFlowTick);
      state.timers.deployFlowTick = null;
      return;
    }
    title.textContent = `Warning: opening Azure portal in ${remaining}s`;
  }, 1000);

  if (state.timers.deployFlow) clearTimeout(state.timers.deployFlow);
  state.timers.deployFlow = setTimeout(() => {
    panel.classList.remove('show');
    if (state.timers.deployFlowTick) {
      clearInterval(state.timers.deployFlowTick);
      state.timers.deployFlowTick = null;
    }
  }, remaining * 1000);
}

// ---------------------------------------------------------------------------
// Image catalog (source-of-truth for image compatibility constraints)
// ---------------------------------------------------------------------------
// Notes:
// - `key` must be unique (validated at startup by validateImageOptionsConfig()).
// - `arch` + `gen` + controller flags drive UI filtering via filteredImages().
// - `ref` is written directly to ARM imageReference, and is also the key used
//   by importFromArmJson() to match imported ARM VMs back to catalog entries
//   (publisher + offer + sku, case-insensitive).
// - Results of filteredImages() are cached per render cycle in
//   state._imageCache to avoid redundant array scans.
// - Keep entries grouped by publisher and sorted by key for easier diffs.
//
// Why we keep multiple images per distro:
// - Architecture: x64 and Arm64 require different image SKUs.
// - Release track: courses/labs may need specific OS major/minor lines.
// - VM Generation: Gen1 vs Gen2 image compatibility differs by VM size/family.
// - Disk controller: some Gen2/size combinations require NVMe-capable images.
//
// Organization policy:
// - Group by publisher in this order: RedHat, Canonical, SUSE.
// - Within each publisher, keep entries ordered by `key` for maintenance.
  const imageOptions = [
    // RedHat

    { key: 'rhel_10_1_x64_gen1', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'RHEL 10.1 (Gen1) (RedHat:RHEL:10_1:latest)',
      ref: { publisher:'RedHat', offer:'RHEL', sku:'10_1', version:'latest' } },

    { key: 'rhel_10_lvm_gen2_x64_gen2', arch: 'x64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'RHEL 10 (Gen2) (RedHat:RHEL:10-lvm-gen2:latest)',
      ref: { publisher:'RedHat', offer:'RHEL', sku:'10-lvm-gen2', version:'latest' } },

    { key: 'rhel_7_6_x64_gen1', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'RHEL:7.6 (Gen1) (RedHat:RHEL:7.6:latest)',
      ref: { publisher:'RedHat', offer:'RHEL', sku:'7.6', version:'latest' } },

    { key: 'rhel_7_8_x64_gen1', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'RHEL:7.8 (Gen1) (RedHat:RHEL:7.8:latest)',
      ref: { publisher:'RedHat', offer:'RHEL', sku:'7.8', version:'latest' } },

    { key: 'rhel_8_9_x64_gen1', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'RHEL 8.9 (Gen1) (RedHat:RHEL:8_9:latest)',
      ref: { publisher:'RedHat', offer:'RHEL', sku:'8_9', version:'latest' } },

    { key: 'rhel_8_lvm_gen2_x64_gen2', arch: 'x64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'RHEL 8 (Gen2) (RedHat:RHEL:8-lvm-gen2:latest)',
      ref: { publisher:'RedHat', offer:'RHEL', sku:'8-lvm-gen2', version:'latest' } },

    { key: 'rhel_9_7_x64_gen1', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'RHEL 9.7 (Gen1) (RedHat:RHEL:9_7:latest)',
      ref: { publisher:'RedHat', offer:'RHEL', sku:'9_7', version:'latest' } },

    { key: 'rhel_9_lvm_gen2_x64_gen2', arch: 'x64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'RHEL 9 (Gen2) (RedHat:RHEL:9-lvm-gen2:latest)',
      ref: { publisher:'RedHat', offer:'RHEL', sku:'9-lvm-gen2', version:'latest' } },

    { key: 'rhel_arm64_10_1_arm64_arm64_gen2', arch: 'Arm64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'RHEL 10.1 Arm64 (Gen2) (RedHat:rhel-arm64:10_1-arm64:latest)',
      ref: { publisher:'RedHat', offer:'rhel-arm64', sku:'10_1-arm64', version:'latest' } },

    { key: 'rhel_arm64_8_10_arm64_arm64_gen2', arch: 'Arm64', gen: 'Gen2', nvmeCapable: false, scsiCapable: true,
      label: 'RHEL 8.10 Arm64 (Gen2) (RedHat:rhel-arm64:8_10-arm64:latest)',
      ref: { publisher:'RedHat', offer:'rhel-arm64', sku:'8_10-arm64', version:'latest' } },

    { key: 'rhel_arm64_9_7_arm64_arm64_gen2', arch: 'Arm64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'RHEL 9.7 Arm64 (Gen2) (RedHat:rhel-arm64:9_7-arm64:latest)',
      ref: { publisher:'RedHat', offer:'rhel-arm64', sku:'9_7-arm64', version:'latest' } },

    { key: 'rhel_raw_10_1_x64_gen1', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'RHEL Raw 10.1 (Gen1) (RedHat:rhel-raw:10_1:latest)',
      ref: { publisher:'RedHat', offer:'rhel-raw', sku:'10_1', version:'latest' } },

    { key: 'rhel_raw_10_raw_gen2_x64_gen2', arch: 'x64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'RHEL Raw 10 (Gen2) (RedHat:rhel-raw:10-raw-gen2:latest)',
      ref: { publisher:'RedHat', offer:'rhel-raw', sku:'10-raw-gen2', version:'latest' } },

    { key: 'rhel_raw_10_raw_x64_gen1', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'RHEL Raw 10 (Gen1) (RedHat:rhel-raw:10-raw:latest)',
      ref: { publisher:'RedHat', offer:'rhel-raw', sku:'10-raw', version:'latest' } },

    { key: 'rhel_raw_89_gen2_x64_gen2', arch: 'x64', gen: 'Gen2', nvmeCapable: false, scsiCapable: true,
      label: 'RHEL Raw 8.9 (Gen2) (RedHat:rhel-raw:89-gen2:latest)',
      ref: { publisher:'RedHat', offer:'rhel-raw', sku:'89-gen2', version:'latest' } },

    { key: 'rhel_raw_8_4_x64_gen1', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'RHEL Raw 8.4 (Gen1) (RedHat:rhel-raw:8_4:latest)',
      ref: { publisher:'RedHat', offer:'rhel-raw', sku:'8_4', version:'latest' } },

    { key: 'rhel_raw_8_9_x64_gen1', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'RHEL Raw 8.9 (Gen1) (RedHat:rhel-raw:8_9:latest)',
      ref: { publisher:'RedHat', offer:'rhel-raw', sku:'8_9', version:'latest' } },

    { key: 'rhel_raw_8_raw_gen2_x64_gen2', arch: 'x64', gen: 'Gen2', nvmeCapable: false, scsiCapable: true,
      label: 'RHEL Raw 8 (Gen2) (RedHat:rhel-raw:8-raw-gen2:latest)',
      ref: { publisher:'RedHat', offer:'rhel-raw', sku:'8-raw-gen2', version:'latest' } },

    { key: 'rhel_raw_8_raw_x64_gen1', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'RHEL Raw 8 (Gen1) (RedHat:rhel-raw:8-raw:latest)',
      ref: { publisher:'RedHat', offer:'rhel-raw', sku:'8-raw', version:'latest' } },

    { key: 'rhel_raw_9_5_x64_gen1', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'RHEL Raw 9.5 (Gen1) (RedHat:rhel-raw:9_5:latest)',
      ref: { publisher:'RedHat', offer:'rhel-raw', sku:'9_5', version:'latest' } },

    { key: 'rhel_raw_9_raw_gen2_x64_gen2', arch: 'x64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'RHEL Raw 9 (Gen2) (RedHat:rhel-raw:9-raw-gen2:latest)',
      ref: { publisher:'RedHat', offer:'rhel-raw', sku:'9-raw-gen2', version:'latest' } },

    { key: 'rhel_raw_9_raw_x64_gen1', arch: 'x64', gen: 'Gen1', nvmeCapable: true, scsiCapable: true,
      label: 'RHEL Raw 9 (Gen1) (RedHat:rhel-raw:9-raw:latest)',
      ref: { publisher:'RedHat', offer:'rhel-raw', sku:'9-raw', version:'latest' } },

    { key: 'rhel_sap_ha_84sapha_gen2_x64_gen2', arch: 'x64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'RHEL SAP HA 8.4 (Gen2) (RedHat:RHEL-SAP-HA:84sapha-gen2:latest)',
      ref: { publisher:'RedHat', offer:'RHEL-SAP-HA', sku:'84sapha-gen2', version:'latest' } },

    { key: 'rhel_sap_ha_96sapha_gen2_x64_gen2', arch: 'x64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'RHEL SAP HA 9.6 (Gen2) (RedHat:RHEL-SAP-HA:96sapha-gen2:latest)',
      ref: { publisher:'RedHat', offer:'RHEL-SAP-HA', sku:'96sapha-gen2', version:'latest' } },

    // Debian
    { key: 'debian_11_11_x64_gen1_latest', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'Debian 11 x86_64 (Gen1) (Debian:debian-11:11:latest)',
      ref: { publisher:'Debian', offer:'debian-11', sku:'11', version:'latest' } },

    { key: 'debian_12_12_x64_gen1_latest', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'Debian 12 x86_64 (Gen1) (Debian:debian-12:12:latest)',
      ref: { publisher:'Debian', offer:'debian-12', sku:'12', version:'latest' } },
      
    { key: 'debian_13_13_x64_gen1_latest', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'Debian 13 x86_64 (Gen1) (Debian:debian-13:13:latest)',
      ref: { publisher:'Debian', offer:'debian-13', sku:'13', version:'latest' } },      

    { key: 'debian_11_11_gen2_x64_gen2_latest', arch: 'x64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'Debian 11 x86_64 (Gen2) (Debian:debian-11:11-gen2:latest)',
      ref: { publisher:'Debian', offer:'debian-11', sku:'11-gen2', version:'latest' } },

    { key: 'debian_12_12_gen2_x64_gen2_latest', arch: 'x64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'Debian 12 x86_64 (Gen2) (Debian:debian-12:12-gen2:latest)',
      ref: { publisher:'Debian', offer:'debian-12', sku:'12-gen2', version:'latest' } },
      
    { key: 'debian_13_13_gen2_x64_gen2_latest', arch: 'x64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'Debian 13 x86_64 (Gen2) (Debian:debian-13:13-gen2:latest)',
      ref: { publisher:'Debian', offer:'debian-13', sku:'13-gen2', version:'latest' } },      

    { key: 'debian_12_12_arm64_arm64_gen2_latest', arch: 'Arm64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'Debian 12 Arm64 (Gen2) (Debian:debian-12:12-arm64:latest)',
      ref: { publisher:'Debian', offer:'debian-12', sku:'12-arm64', version:'latest' } },

    { key: 'debian_13_13_arm64_arm64_gen2_latest', arch: 'Arm64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'Debian 13 Arm64 (Gen2) (Debian:debian-13:13-arm64:latest)',
      ref: { publisher:'Debian', offer:'debian-13', sku:'13-arm64', version:'latest' } },      
    
    // Canonical
    { key: 'ubuntu_24_04_lts_server_arm64_arm64_gen2', arch: 'Arm64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'Ubuntu 24.04 Arm64 (Gen2) (Canonical:ubuntu-24_04-lts:server-arm64:latest)',
      ref: { publisher:'Canonical', offer:'ubuntu-24_04-lts', sku:'server-arm64', version:'latest' } },

    { key: 'ubuntu_24_04_lts_server_gen1_x64_gen1', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'Ubuntu 24.04 (Gen1) (Canonical:ubuntu-24_04-lts:server-gen1:latest)',
      ref: { publisher:'Canonical', offer:'ubuntu-24_04-lts', sku:'server-gen1', version:'latest' } },

    { key: 'ubuntu_24_04_lts_server_x64_gen2', arch: 'x64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'Ubuntu 24.04 (Gen2) (Canonical:ubuntu-24_04-lts:server:latest)',
      ref: { publisher:'Canonical', offer:'ubuntu-24_04-lts', sku:'server', version:'latest' } },

    // SUSE
    { key: 'sles_12_sp5_gen2_x64_gen2_latest', arch: 'x64', gen: 'Gen2', nvmeCapable: false, scsiCapable: true,
      label: 'SLES 12 SP5 x86_64 (Gen2) (SUSE:sles-12-sp5:gen2:latest)',
      ref: { publisher:'SUSE', offer:'sles-12-sp5', sku:'gen2', version:'latest' } },

    { key: 'sles_15_sp6_gen2_x64_gen2', arch: 'x64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'SLES 15 SP6 x86_64(Gen2) (SUSE:sles-15-sp6:gen2:latest)',
      ref: { publisher:'SUSE', offer:'sles-15-sp6', sku:'gen2', version:'latest' } },

    { key: 'sles_15_sp7_gen1_x64_gen1', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'SLES 15 SP7 x86_64 (Gen1) (SUSE:sles-15-sp7:gen1:latest)',
      ref: { publisher:'SUSE', offer:'sles-15-sp7', sku:'gen1', version:'latest' } },

    { key: 'sles_15_sp7_arm64_gen2_arm64_gen2', arch: 'Arm64', gen: 'Gen2', nvmeCapable: false, scsiCapable: true,
      label: 'SLES 15 SP7 Arm64 (Gen2) (SUSE:sles-15-sp7-arm64:gen2:latest)',
      ref: { publisher:'SUSE', offer:'sles-15-sp7-arm64', sku:'gen2', version:'latest' } },

    { key: 'sles_15_sp7_basic_gen2_x64_gen2', arch: 'x64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'SLES 15 SP7 basic x86_64 (Gen2) (SUSE:sles-15-sp7-basic:gen2:latest)',
      ref: { publisher:'SUSE', offer:'sles-15-sp7-basic', sku:'gen2', version:'latest' } },

    { key: 'sles_16_0_x86_64_gen1_x64_gen1', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'SLES 16.0 x86_64 (Gen1) (SUSE:sles-16-0-x86-64:gen1:latest)',
      ref: { publisher:'SUSE', offer:'sles-16-0-x86-64', sku:'gen1', version:'latest' } },

    { key: 'sles_16_0_x86_64_gen2_x64_gen2', arch: 'x64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'SLES 16.0 x86_64 (Gen2) (SUSE:sles-16-0-x86-64:gen2:latest)',
      ref: { publisher:'SUSE', offer:'sles-16-0-x86-64', sku:'gen2', version:'latest' } },

    { key: 'sles_sap_15_sp7_gen1_x64_gen1', arch: 'x64', gen: 'Gen1', nvmeCapable: false, scsiCapable: true,
      label: 'SLES SAP 15 SP7 x86_64 (Gen1) (SUSE:sles-sap-15-sp7:gen1:latest)',
      ref: { publisher:'SUSE', offer:'sles-sap-15-sp7', sku:'gen1', version:'latest' } },

    { key: 'sles_sap_15_sp7_gen2_x64_gen2', arch: 'x64', gen: 'Gen2', nvmeCapable: true, scsiCapable: true,
      label: 'SLES SAP 15 SP7 x86_64 (Gen2) (SUSE:sles-sap-15-sp7:gen2:latest)',
      ref: { publisher:'SUSE', offer:'sles-sap-15-sp7', sku:'gen2', version:'latest' } },
  ];

  const imageSortCollator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });
  const imagePublisherOrder = new Map();
  imageOptions.forEach((img) => {
    const publisher = String((img.ref && img.ref.publisher) || '').trim();
    if (publisher && !imagePublisherOrder.has(publisher)) {
      imagePublisherOrder.set(publisher, imagePublisherOrder.size);
    }
  });
  imageOptions.sort((a, b) => {
    const ap = String((a.ref && a.ref.publisher) || '');
    const bp = String((b.ref && b.ref.publisher) || '');
    const apr = imagePublisherOrder.get(ap) ?? Number.MAX_SAFE_INTEGER;
    const bpr = imagePublisherOrder.get(bp) ?? Number.MAX_SAFE_INTEGER;
    if (apr !== bpr) return apr - bpr;

    const ak = String(a.key || '');
    const bk = String(b.key || '');
    const byKey = imageSortCollator.compare(ak, bk);
    if (byKey !== 0) return byKey;

    const al = String(a.label || '');
    const bl = String(b.label || '');
    return imageSortCollator.compare(al, bl);
  });

  function validateImageOptionsConfig(options) {
    const keySeen = new Map();
    const refSeen = new Map();
    const issues = [];

    options.forEach((img, idx) => {
      const key = String(img && img.key || '').trim();
      const ref = img && img.ref ? img.ref : {};
      const refId = [ref.publisher, ref.offer, ref.sku, ref.version].map(v => String(v || '').trim()).join(':');

      if (!key) {
        issues.push(`imageOptions[${idx}] is missing key`);
      } else if (keySeen.has(key)) {
        issues.push(`Duplicate image key '${key}' at indexes ${keySeen.get(key)} and ${idx}`);
      } else {
        keySeen.set(key, idx);
      }

      if (refId === ':::') {
        issues.push(`imageOptions[${idx}] has incomplete ref`);
      } else if (refSeen.has(refId)) {
        issues.push(`Duplicate image ref '${refId}' at indexes ${refSeen.get(refId)} and ${idx}`);
      } else {
        refSeen.set(refId, idx);
      }
    });

    if (issues.length) {
      const msg = `Invalid imageOptions configuration:\n- ${issues.join('\n- ')}`;
      console.error(msg);
      throw new Error(msg);
    }
  }

  validateImageOptionsConfig(imageOptions);

  // ---------------------------------------------------------------------------
  // VM size catalog (source-of-truth for size-level capabilities)
  // ---------------------------------------------------------------------------
  // Notes:
  // - Each entry is validated at startup by validateSizeOptionsConfig().
  // - `name` must be unique and is matched case-insensitively by
  //   importFromArmJson() when importing ARM templates.
  // - `tags.architectures` constrains which images are compatible.
  // - `tags.generations` constrains VM generation selection.
  // - `tags.diskControllersByGen` constrains controller selection by generation.
  // - `tags.diskSkuSupport` gates allowed data disk SKUs in the UI.
  // - `tags.accelNetMode` controls NIC accelerated networking behavior
  //   ('required' | 'optional' | 'unsupported').
  // - `tags.ephemeralOsDiskSupported` is used by the size filter panel.
  // - `tags.maxNics` and `tags.maxDataDisks` enforce attachment limits.
  // - The multi-filter panel (sizeFilterMeta) filters this array via
  //   sizeMatchesFilters() across 9 dimensions: family, arch, gen,
  //   controller, diskSku, accel, ephemeral, minNics, minDataDisks.
  const sizeOptions = [
  // -------------------------------------------------------------------------
  // B-family (burstable)
  // -------------------------------------------------------------------------
  // Standard_B2s: Small burstable x64 size for lightweight labs.
  {
    name: 'Standard_B2s',
    tags: {
      architectures: ['x64'],
      generations: ['Gen1','Gen2'],
      diskControllersByGen: {
        Gen1: ['SCSI'],
        Gen2: ['SCSI']
      },
      diskSkuSupport: {
        Standard_LRS: true,
        StandardSSD_LRS: true,
        Premium_LRS: false,
        PremiumV2_LRS: false,
        UltraSSD_LRS: true
      },
      accelNetMode: 'unsupported',
      ephemeralOsDiskSupported: true,      
      maxNics: 3,
      maxDataDisks: 4
    }
  },

  // -------------------------------------------------------------------------
  // D-family (general purpose)
  // -------------------------------------------------------------------------
  // Standard_D2s_v3: General-purpose x64 v3 with broad Gen1/Gen2 compatibility.
  {
    name: 'Standard_D2s_v3',
    tags: {
      architectures: ['x64'],
      generations: ['Gen1','Gen2'],
      diskControllersByGen: {
        Gen1: ['SCSI'],
        Gen2: ['SCSI']
      },
      diskSkuSupport: {
        Standard_LRS: true,
        StandardSSD_LRS: true,
        Premium_LRS: true,
        PremiumV2_LRS: false,
        UltraSSD_LRS: true
      },
      accelNetMode: 'optional',
      ephemeralOsDiskSupported: true,      
      maxNics: 2,
      maxDataDisks: 4
    }
  },

  // Standard_D2s_v6: Newer x64 v6 size with NVMe on Gen2.
  {
    name: 'Standard_D2s_v6',
    tags: {
      architectures: ['x64'],
      generations: ['Gen2'],
      diskControllersByGen: {
        Gen2: ['SCSI','NVMe']
      },
      diskSkuSupport: {
        Standard_LRS: true,
        StandardSSD_LRS: true,
        Premium_LRS: true,
        PremiumV2_LRS: true,
        UltraSSD_LRS: true
      },
      accelNetMode: 'optional',
      ephemeralOsDiskSupported: false,      
      maxNics: 2,
      maxDataDisks: 8
    }
  },

  // Standard_D2ps_v6: Arm64 v6 general-purpose size.
  {
    name: 'Standard_D2ps_v6',
    tags: {
      architectures: ['Arm64'],
      generations: ['Gen2'],
      diskControllersByGen: {
        Gen2: ['SCSI']
      },
      diskSkuSupport: {
        Standard_LRS: true,
        StandardSSD_LRS: true,
        Premium_LRS: true,
        PremiumV2_LRS: false,
        UltraSSD_LRS: true
      },
      accelNetMode: 'optional',
      ephemeralOsDiskSupported: false,
      maxNics: 2,
      maxDataDisks: 8
    }
  },

  // Standard_D4s_v5: Common x64 lab size with required accelerated networking.
  {
    name: 'Standard_D4s_v5',
    tags: {
      architectures: ['x64'],
      generations: ['Gen1','Gen2'],
      diskControllersByGen: {
        Gen1: ['SCSI'],
        Gen2: ['SCSI']
      },
      diskSkuSupport: {
        Standard_LRS: true,
        StandardSSD_LRS: true,
        Premium_LRS: true,
        PremiumV2_LRS: false,
        UltraSSD_LRS: true
      },
      accelNetMode: 'required',
      ephemeralOsDiskSupported: false,
      maxNics: 2,
      maxDataDisks: 8
    }
  },

  // Standard_D4ls_v5: Storage-focused x64 D-series variant.
  {
    name: 'Standard_D4ls_v5',
    tags: {
      architectures: ['x64'],
      generations: ['Gen1','Gen2'],
      diskControllersByGen: {
        Gen1: ['SCSI'],
        Gen2: ['SCSI']
      },
      diskSkuSupport: {
        Standard_LRS: true,
        StandardSSD_LRS: true,
        Premium_LRS: true,
        PremiumV2_LRS: false,
        UltraSSD_LRS: true
      },
      accelNetMode: 'optional',
      ephemeralOsDiskSupported: false,
      maxNics: 2,
      maxDataDisks: 8
    }
  },

  // -------------------------------------------------------------------------
  // E-family (memory optimized)
  // -------------------------------------------------------------------------
  // Standard_E2bds_v5: Memory-optimized x64 with NVMe support on Gen2.
  {
    name: 'Standard_E2bds_v5',
    tags: {
      architectures: ['x64'],
      generations: ['Gen1','Gen2'],
      diskControllersByGen: {
        Gen1: ['SCSI'],
        Gen2: ['SCSI','NVMe']
      },
      diskSkuSupport: {
        Standard_LRS: true,
        StandardSSD_LRS: true,
        Premium_LRS: true,
        PremiumV2_LRS: true,
        UltraSSD_LRS: true
      },
      accelNetMode: 'optional',
      ephemeralOsDiskSupported: true,
      maxNics: 2,
      maxDataDisks: 4
    }
  },

  // Standard_E2ps_v6: Arm64 memory-optimized v6 size for lightweight workloads.
  {
    name: 'Standard_E2ps_v6',
    tags: {
      architectures: ['Arm64'],
      generations: ['Gen2'],
      diskControllersByGen: {
        Gen2: ['SCSI']
      },
      diskSkuSupport: {
        Standard_LRS: true,
        StandardSSD_LRS: true,
        Premium_LRS: true,
        PremiumV2_LRS: false,
        UltraSSD_LRS: true
      },
      accelNetMode: 'optional',
      ephemeralOsDiskSupported: false,
      maxNics: 2,
      maxDataDisks: 8
    }
  },

  // Standard_E32bds_v5: Larger memory-optimized x64 option for heavier labs.
  {
    name: 'Standard_E32bds_v5',
    tags: {
      architectures: ['x64'],
      generations: ['Gen1','Gen2'],
      diskControllersByGen: {
        Gen1: ['SCSI'],
        Gen2: ['SCSI','NVMe']
      },
      diskSkuSupport: {
        Standard_LRS: true,
        StandardSSD_LRS: true,
        Premium_LRS: true,
        PremiumV2_LRS: true,
        UltraSSD_LRS: true
      },
      accelNetMode: 'optional',
      ephemeralOsDiskSupported: true,      
      maxNics: 8,
      maxDataDisks: 32
    }
  },

  // -------------------------------------------------------------------------
  // F-family (compute optimized)
  // -------------------------------------------------------------------------
  // Standard_F2s_v2: Compute-oriented x64 size with balanced limits.
  {
    name: 'Standard_F2s_v2',
    tags: {
      architectures: ['x64'],
      generations: ['Gen1','Gen2'],
      diskControllersByGen: {
        Gen1: ['SCSI'],
        Gen2: ['SCSI']
      },
      diskSkuSupport: {
        Standard_LRS: true,
        StandardSSD_LRS: true,
        Premium_LRS: true,
        PremiumV2_LRS: false,
        UltraSSD_LRS: true
      },
      accelNetMode: 'optional',
      ephemeralOsDiskSupported: true,      
      maxNics: 2,
      maxDataDisks: 4
    }
  },

  // -------------------------------------------------------------------------
  // L-family (storage optimized)
  // -------------------------------------------------------------------------
  // Standard_L8as_v3: Storage-optimized x64 size with higher disk/NIC capacity.
  {
    name: 'Standard_L8as_v3',
    tags: {
      architectures: ['x64'],
      generations: ['Gen1','Gen2'],
      diskControllersByGen: {
        Gen1: ['SCSI'],
        Gen2: ['SCSI']
      },
      diskSkuSupport: {
        Standard_LRS: true,
        StandardSSD_LRS: true,
        Premium_LRS: true,
        PremiumV2_LRS: false,
        UltraSSD_LRS: true
      },
      accelNetMode: 'optional',
      ephemeralOsDiskSupported: true,      
      maxNics: 4,
      maxDataDisks: 16
    }
  }
];

const maxDiskSizeGbBySku = {
  // Managed disk max sizes (GiB) aligned to common Azure limits.
  // Keep this object as the single source of truth for supported data disk SKUs.
  StandardSSD_LRS: 32767,
  Premium_LRS: 32767,
  PremiumV2_LRS: 65536,
  Standard_LRS: 32767,
  UltraSSD_LRS: 65536
};
const diskSkus = Object.keys(maxDiskSizeGbBySku);

function sizeFamilyForName(name) {
  const raw = String(name || '');
  const m = raw.match(/^Standard_([A-Za-z]+)\d/i);
  if (m && m[1]) return m[1].toUpperCase();
  return '';
}

const sizeFamilyValues = Array.from(
  new Set(sizeOptions.map(s => sizeFamilyForName(s && s.name)).filter(Boolean))
).sort((a, b) => String(a).localeCompare(String(b)));

state.sizeFilters = {
  family: '',
  arch: '',
  gen: '',
  controller: '',
  diskSku: '',
  accel: '',
  ephemeral: '',
  minNics: '',
  minDataDisks: ''
};

const sizeFilterMeta = {
  family: { label: 'Family', values: sizeFamilyValues },
  arch: { label: 'Architecture', values: ['x64', 'Arm64'] },
  gen: { label: 'Generation', values: ['Gen1', 'Gen2'] },
  controller: { label: 'Disk controller', values: ['SCSI', 'NVMe'] },
  diskSku: { label: 'Disk SKU support', values: diskSkus },
  accel: { label: 'Accelerated networking', values: ['required', 'optional', 'unsupported'], valueLabels: { required: 'Required', optional: 'Optional', unsupported: 'Unsupported' } },
  ephemeral: { label: 'Ephemeral OS disk', values: ['supported', 'not-supported'], valueLabels: { supported: 'Supported', 'not-supported': 'Not supported' } },
  minNics: { label: 'Min max NICs', values: ['1', '2', '3', '4', '8', '16'] },
  minDataDisks: { label: 'Min max data disks', values: ['1', '2', '4', '8', '16', '32'] }
};

function validateSizeOptionsConfig(options) {
  const allowedArchitectures = new Set(['x64', 'Arm64']);
  const allowedGenerations = new Set(['Gen1', 'Gen2']);
  const allowedControllers = new Set(['SCSI', 'NVMe']);
  const allowedAccelModes = new Set(['required', 'optional', 'unsupported']);
  const expectedDiskSkus = new Set(diskSkus);

  const nameSeen = new Map();
  const issues = [];

  const isPositiveInteger = (v) => Number.isInteger(v) && v > 0;

  options.forEach((size, idx) => {
    const name = String(size && size.name || '').trim();
    const tags = size && size.tags ? size.tags : null;

    if (!name) {
      issues.push(`sizeOptions[${idx}] is missing name`);
    } else if (nameSeen.has(name)) {
      issues.push(`Duplicate size name '${name}' at indexes ${nameSeen.get(name)} and ${idx}`);
    } else {
      nameSeen.set(name, idx);
    }

    if (!tags || typeof tags !== 'object') {
      issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) is missing tags object`);
      return;
    }

    const architectures = Array.isArray(tags.architectures) ? tags.architectures : [];
    if (!architectures.length) {
      issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) must define at least one architecture`);
    } else {
      architectures.forEach((arch) => {
        if (!allowedArchitectures.has(String(arch))) {
          issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) has unsupported architecture '${arch}'`);
        }
      });
    }

    const generations = Array.isArray(tags.generations) ? tags.generations : [];
    if (!generations.length) {
      issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) must define at least one generation`);
    } else {
      generations.forEach((gen) => {
        if (!allowedGenerations.has(String(gen))) {
          issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) has unsupported generation '${gen}'`);
        }
      });
    }

    const controllerMap = (tags.diskControllersByGen && typeof tags.diskControllersByGen === 'object') ? tags.diskControllersByGen : null;
    if (!controllerMap) {
      issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) is missing diskControllersByGen`);
    } else {
      Object.keys(controllerMap).forEach((genKey) => {
        if (!allowedGenerations.has(genKey)) {
          issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) has unknown diskControllersByGen key '${genKey}'`);
          return;
        }
        const controllers = controllerMap[genKey];
        if (!Array.isArray(controllers) || controllers.length === 0) {
          issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) must define at least one controller for ${genKey}`);
          return;
        }
        controllers.forEach((ctl) => {
          if (!allowedControllers.has(String(ctl))) {
            issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) has unsupported controller '${ctl}' for ${genKey}`);
          }
        });
      });

      generations.forEach((gen) => {
        if (!Array.isArray(controllerMap[gen]) || controllerMap[gen].length === 0) {
          issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) is missing disk controller mapping for ${gen}`);
        }
      });
    }

    const diskSupport = (tags.diskSkuSupport && typeof tags.diskSkuSupport === 'object') ? tags.diskSkuSupport : null;
    if (!diskSupport) {
      issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) is missing diskSkuSupport`);
    } else {
      expectedDiskSkus.forEach((sku) => {
        if (typeof diskSupport[sku] !== 'boolean') {
          issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) diskSkuSupport.${sku} must be boolean`);
        }
      });

      Object.keys(diskSupport).forEach((sku) => {
        if (!expectedDiskSkus.has(sku)) {
          issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) has unknown diskSkuSupport key '${sku}'`);
        }
      });
    }

    if (!allowedAccelModes.has(String(tags.accelNetMode || ''))) {
      issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) has invalid accelNetMode '${tags.accelNetMode}'`);
    }

    if (!isPositiveInteger(Number(tags.maxNics))) {
      issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) maxNics must be a positive integer`);
    }

    if (!isPositiveInteger(Number(tags.maxDataDisks))) {
      issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) maxDataDisks must be a positive integer`);
    }

    if (tags.ephemeralOsDiskSupported !== undefined && typeof tags.ephemeralOsDiskSupported !== 'boolean') {
      issues.push(`sizeOptions[${idx}] (${name || 'unknown'}) ephemeralOsDiskSupported must be boolean when provided`);
    }
  });

  if (issues.length) {
    const msg = `Invalid sizeOptions configuration:\n- ${issues.join('\n- ')}`;
    console.error(msg);
    throw new Error(msg);
  }
}

validateSizeOptionsConfig(sizeOptions);

  // ---------------------------------------------------------------------------
  // View-model defaults and lookup helpers
  // ---------------------------------------------------------------------------
  function defaultNic(idx) {
    return { id: uid(), name: `nic${idx+1}`, accelerated: false, publicIp: idx === 0 };
  }

  function sizeByName(name) {
    return sizeOptions.find(s => s.name === name) || sizeOptions[0];
  }

  function sizeMatchesFilters(size) {
    const tags = (size && size.tags) || {};
    const family = sizeFamilyForName(size && size.name);
    const archs = tags.architectures || [];
    const gens = tags.generations || [];
    const ctlMap = tags.diskControllersByGen || {};
    const diskSupport = tags.diskSkuSupport || {};
    const accel = String(tags.accelNetMode || (tags.accelNet ? 'optional' : 'unsupported'));
    const ephemeral = !!tags.ephemeralOsDiskSupported;
    const maxNics = Number(tags.maxNics || 0);
    const maxDataDisks = Number(tags.maxDataDisks || 0);

    if (sizeFilters.family && family !== sizeFilters.family) return false;
    if (sizeFilters.arch && !archs.includes(sizeFilters.arch)) return false;
    if (sizeFilters.gen && !gens.includes(sizeFilters.gen)) return false;
    if (sizeFilters.controller) {
      const hasController = Object.values(ctlMap).some(arr => Array.isArray(arr) && arr.includes(sizeFilters.controller));
      if (!hasController) return false;
    }
    if (sizeFilters.diskSku && !diskSupport[sizeFilters.diskSku]) return false;
    if (sizeFilters.accel && accel !== sizeFilters.accel) return false;
    if (sizeFilters.ephemeral === 'supported' && !ephemeral) return false;
    if (sizeFilters.ephemeral === 'not-supported' && ephemeral) return false;
    if (sizeFilters.minNics && maxNics < Number(sizeFilters.minNics)) return false;
    if (sizeFilters.minDataDisks && maxDataDisks < Number(sizeFilters.minDataDisks)) return false;

    return true;
  }

  function filteredSizeOptions() {
    return sizeOptions.filter(sizeMatchesFilters);
  }

  function sizeIsOutsideFilters(sizeName) {
    const size = sizeByName(sizeName);
    return !sizeMatchesFilters(size);
  }

  function nextDefaultVmName() {
    const used = new Set(vms.map(v => String(v.name || '').trim().toLowerCase()).filter(Boolean));
    let n = 1;
    while (used.has(`vm${n}`.toLowerCase())) n += 1;
    return `vm${n}`;
  }

  function nextDefaultNicName(vm) {
    const used = new Set((vm.nics || []).map(n => String((n && n.name) || '').trim().toLowerCase()).filter(Boolean));
    let n = 1;
    while (used.has(`nic${n}`.toLowerCase())) n += 1;
    return `nic${n}`;
  }

  function nextCloneVmName(sourceName) {
    const used = new Set(vms.map(v => String(v.name || '').trim().toLowerCase()).filter(Boolean));
    let base = String(sourceName || 'vm').trim() || 'vm';

    // Normalize sources like "vm1-clone", "vm1-clone-2", or legacy "vm1-clone-clone".
    while (/-clone(?:-\d+)?$/i.test(base)) {
      base = base.replace(/-clone(?:-\d+)?$/i, '');
    }
    if (!base) base = 'vm';

    let n = 1;
    let candidate = `${base}-clone-${n}`;
    while (used.has(candidate.toLowerCase())) {
      n += 1;
      candidate = `${base}-clone-${n}`;
    }

    return candidate;
  }

  function duplicateVmNamesSet() {
    if (state._dupVmNamesCache) return state._dupVmNamesCache;
    const counts = new Map();
    vms.forEach(vm => {
      const k = String((vm && vm.name) || '').trim().toLowerCase();
      if (!k) return;
      counts.set(k, (counts.get(k) || 0) + 1);
    });
    const dupes = new Set();
    counts.forEach((count, key) => {
      if (count > 1) dupes.add(key);
    });
    state._dupVmNamesCache = dupes;
    return dupes;
  }

  function hasDuplicateVmNameAt(index) {
    const vm = vms[index];
    if (!vm) return false;
    const key = String(vm.name || '').trim().toLowerCase();
    if (!key) return false;
    return duplicateVmNamesSet().has(key);
  }

  function vmNameFormatError(name) {
    const trimmed = String(name || '').trim();
    if (!trimmed) return 'VM name is required.';
    if (trimmed.length > LIMITS.VM_NAME_MAX_LEN) return `VM name must be 1-${LIMITS.VM_NAME_MAX_LEN} characters.`;
    const innerMax = LIMITS.VM_NAME_MAX_LEN - 2; // regex inner repetition
    const re = new RegExp(`^[A-Za-z0-9](?:[A-Za-z0-9-]{0,${innerMax}}[A-Za-z0-9])?$`);
    if (!re.test(trimmed)) {
      return `VM name must be 1-${LIMITS.VM_NAME_MAX_LEN} chars, use letters/numbers/hyphen only, and start/end with letter or number.`;
    }
    return '';
  }

  function vmNameErrorAt(index) {
    const vm = vms[index];
    if (!vm) return '';
    const formatErr = vmNameFormatError(vm.name);
    if (formatErr) return formatErr;
    if (hasDuplicateVmNameAt(index)) return 'VM name must be unique. Use a different name.';
    return '';
  }

  function hasAnyVmNameErrors() {
    return vms.some((_, i) => !!vmNameErrorAt(i));
  }

  function nicNameMaxLengthForVmName(vmName) {
    // NIC name contributes to both:
    // - NIC resource: <vm_name>-<nic_name>
    // - PIP resource: <vm_name>-<nic_name>-pip
    // PIP is stricter: vm + 1 + nic + 4 <= 80  => nic <= 75 - vm
    const vmLen = String(vmName || '').trim().length;
    return Math.max(1, LIMITS.AZ_NETWORK_NAME_MAX_LEN - vmLen - 5);
  }

  function nicNameFormatError(vmName, nicName) {
    const trimmed = String(nicName || '').trim();
    if (!trimmed) return 'NIC name is required.';

    const maxLen = nicNameMaxLengthForVmName(vmName);
    if (trimmed.length > maxLen) {
      return `NIC name is too long for this VM name. Max ${maxLen} chars so '${vmName}-${trimmed}' and '${vmName}-${trimmed}-pip' stay within ${LIMITS.AZ_NETWORK_NAME_MAX_LEN} chars.`;
    }

    if (!/^[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?$/.test(trimmed)) {
      return 'NIC name can use letters, numbers, and hyphen only, and must start/end with letter or number.';
    }

    return '';
  }

  function duplicateNicNamesSet(vm) {
    const counts = new Map();
    (vm.nics || []).forEach(nic => {
      const key = String((nic && nic.name) || '').trim().toLowerCase();
      if (!key) return;
      counts.set(key, (counts.get(key) || 0) + 1);
    });
    const dupes = new Set();
    counts.forEach((count, key) => {
      if (count > 1) dupes.add(key);
    });
    return dupes;
  }

  function nicNameError(vm, nic) {
    const formatErr = nicNameFormatError(vm.name, nic.name);
    if (formatErr) return formatErr;

    const key = String((nic && nic.name) || '').trim().toLowerCase();
    if (!key) return 'NIC name is required.';
    if (duplicateNicNamesSet(vm).has(key)) return 'NIC name must be unique inside the VM.';

    return '';
  }

  function hasAnyNicNameErrors() {
    return vms.some(vm => (vm.nics || []).some(nic => !!nicNameError(vm, nic)));
  }

  function diskSizeError(disk) {
    const size = Number(disk && disk.sizeGB);
    const sku = String((disk && disk.sku) || '');
    const maxSize = maxDiskSizeGbBySku[sku] || LIMITS.FALLBACK_MAX_DISK_GB;

    if (!Number.isFinite(size) || size <= 1) {
      return 'Data disk size must be greater than 1 GB.';
    }
    if (size > maxSize) {
      return `Data disk size exceeds limit for ${sku || 'selected SKU'}. Max ${maxSize} GB.`;
    }
    return '';
  }

  function hasAnyDiskValidationErrors() {
    return vms.some(vm => (vm.disks || []).some(d => !!diskSizeError(d)));
  }

  function allowedGenerationsFor(vm) {
    return sizeByName(vm.size).tags.generations;
  }

  function allowedArchitecturesFor(vm) {
    const sz = sizeByName(vm.size);
    return (sz.tags && sz.tags.architectures && sz.tags.architectures.length) ? sz.tags.architectures : ['x64'];
  }

  function imageByKey(key) {
    return imageOptions.find(i => i.key === key);
  }

  function allowedControllersFor(vm) {
  const sz = sizeByName(vm.size);
  const map = (sz.tags && sz.tags.diskControllersByGen) ? sz.tags.diskControllersByGen : {};
  return map[vm.gen] || ['SCSI'];
}
function accelNetSupportedFor(vm) {
    return accelNetModeFor(vm) !== 'unsupported';
  }

  function accelNetRequiredFor(vm) {
    return accelNetModeFor(vm) === 'required';
  }

  function accelNetModeFor(vm) {
    const tags = sizeByName(vm.size).tags || {};
    if (tags.accelNetMode) return tags.accelNetMode;
    return tags.accelNet ? 'optional' : 'unsupported';
  }

  function resolvedAccelForNic(vm, nic) {
    const mode = accelNetModeFor(vm);
    if (mode === 'required') return true;
    if (mode === 'unsupported') return false;
    return !!nic.accelerated;
  }

  function maxNicsFor(vm) {
    const tags = sizeByName(vm.size).tags || {};
    return Number(tags.maxNics || 2);
  }

  function maxDataDisksFor(vm) {
    const tags = sizeByName(vm.size).tags || {};
    return Number(tags.maxDataDisks || 4);
  }

  function nicAttachmentCountError(vm) {
    const max = maxNicsFor(vm);
    const count = (vm.nics || []).length;
    if (count > max) return `VM size ${vm.size} supports up to ${max} NIC(s). Current: ${count}.`;
    return '';
  }

  function diskAttachmentCountError(vm) {
    const max = maxDataDisksFor(vm);
    const count = (vm.disks || []).length;
    if (count > max) return `VM size ${vm.size} supports up to ${max} data disk(s). Current: ${count}.`;
    return '';
  }

  function hasAnyAttachmentLimitErrors() {
    return vms.some(vm => !!nicAttachmentCountError(vm) || !!diskAttachmentCountError(vm));
  }

  function diskSupportFlagsFor(vm) {
    const tags = sizeByName(vm.size).tags || {};
    const flags = tags.diskSkuSupport || {};
    const fallback = {
      Standard_LRS: true,
      StandardSSD_LRS: true,
      Premium_LRS: true,
      PremiumV2_LRS: false,
      UltraSSD_LRS: false
    };
    return {
      Standard_LRS: flags.Standard_LRS !== undefined ? !!flags.Standard_LRS : fallback.Standard_LRS,
      StandardSSD_LRS: flags.StandardSSD_LRS !== undefined ? !!flags.StandardSSD_LRS : fallback.StandardSSD_LRS,
      Premium_LRS: flags.Premium_LRS !== undefined ? !!flags.Premium_LRS : fallback.Premium_LRS,
      PremiumV2_LRS: flags.PremiumV2_LRS !== undefined ? !!flags.PremiumV2_LRS : fallback.PremiumV2_LRS,
      UltraSSD_LRS: flags.UltraSSD_LRS !== undefined ? !!flags.UltraSSD_LRS : fallback.UltraSSD_LRS
    };
  }

  function supportedDiskSkusFor(vm) {
    const flags = diskSupportFlagsFor(vm);
    return diskSkus.filter(s => !!flags[s]);
  }

  function defaultDiskSkuFor(vm) {
    const supported = supportedDiskSkusFor(vm);
    if (supported.includes('StandardSSD_LRS')) return 'StandardSSD_LRS';
    return supported[0] || 'Standard_LRS';
  }

  function normalizeDataDiskSkus(vm) {
    const supported = supportedDiskSkusFor(vm);
    const fallback = defaultDiskSkuFor(vm);
    let changed = 0;
    (vm.disks || []).forEach(d => {
      if (!supported.includes(d.sku)) {
        d.sku = fallback;
        changed += 1;
      }
    });
    return changed;
  }

  function filteredImages(vm, includePublisherFilter) {
    // Per-cycle cache: key = size|gen|controller|publisherFilter|includePublisher
    if (!state._imageCache) state._imageCache = new Map();
    const cacheKey = `${vm.size}|${vm.gen}|${vm.diskControllerType}|${includePublisherFilter ? vm.publisherFilter || '' : ''}|${!!includePublisherFilter}`;
    if (state._imageCache.has(cacheKey)) return state._imageCache.get(cacheKey);

    let candidates = imageOptions.filter(img => img.gen === vm.gen);
    const allowedArch = allowedArchitecturesFor(vm);
    candidates = candidates.filter(img => allowedArch.includes(img.arch || 'x64'));

    const controller = vm.diskControllerType;
    if (controller === 'NVMe') candidates = candidates.filter(img => !!img.nvmeCapable);
    if (controller === 'SCSI') candidates = candidates.filter(img => !!img.scsiCapable);

    if (includePublisherFilter) {
      const publisher = String(vm.publisherFilter || '').trim();
      if (publisher) candidates = candidates.filter(img => String((img.ref && img.ref.publisher) || '') === publisher);
    }

    state._imageCache.set(cacheKey, candidates);
    return candidates;
  }

  function filterImagesFor(vm) {
    // Filter by generation + architecture + controller + optional publisher.
    return filteredImages(vm, true);
  }

function baseFilteredImagesFor(vm) {
  // Same as above but without publisher filter (used to populate publisher list).
  return filteredImages(vm, false);
}

function publishersFor(vm) {
  const pubs = new Set(baseFilteredImagesFor(vm).map(i => (i.ref && i.ref.publisher) || '').filter(Boolean));
  return Array.from(pubs).sort((a, b) => String(a).localeCompare(String(b)));
}
state.vms = [
  {
    id: uid(),
    name: 'vm1',
    size: 'Standard_D4s_v5',
    gen: 'Gen2',
    imageKey: 'ubuntu_24_04_lts_server_x64_gen2',
    diskControllerType: 'SCSI',
    customData: '',
    rebootRequired: false,
    nics: [ defaultNic(0) ],
    disks: []
  }
];

function loadUiState() {
  try {
    const raw = localStorage.getItem(UI_STATE_STORAGE_KEY);
    if (!raw) return;
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') return;

    if (Array.isArray(parsed.vms) && parsed.vms.length) {
      state.vms = parsed.vms;
    }
    if (parsed.sizeFilters && typeof parsed.sizeFilters === 'object') {
      Object.assign(state.sizeFilters, parsed.sizeFilters);
    }
    if (Number.isInteger(parsed.activeVmIndex) && parsed.activeVmIndex >= 0) {
      state.activeVmIndex = parsed.activeVmIndex;
    }
  } catch (err) {
    console.warn('Failed to load saved UI state:', err);
  }
}

function saveUiState() {
  try {
    const payload = {
      vms: state.vms,
      sizeFilters: state.sizeFilters,
      activeVmIndex: state.activeVmIndex
    };
    localStorage.setItem(UI_STATE_STORAGE_KEY, JSON.stringify(payload));
  } catch (err) {
    console.warn('Failed to save UI state:', err);
  }
}

Object.defineProperties(globalThis, {
  vms: {
    get() { return state.vms; },
    set(value) { state.vms = value; },
    configurable: true
  },
  active: {
    get() { return state.activeVmIndex; },
    set(value) { state.activeVmIndex = value; },
    configurable: true
  },
  sizeFilters: {
    get() { return state.sizeFilters; },
    configurable: true
  }
});

loadUiState();

  // -----------------------------
  // ARM Generator (pure transform from sanitized VM model -> ARM template object)
  // -----------------------------
  function generateArmTemplate(vms) {
    const imageMap = Object.fromEntries(imageOptions.map(o => [o.key, o.ref]));
    const locationExpr = "[resourceGroup().location]";
    const hasAnyUltraSsdDataDisk = (vms || []).some(vm => (vm.disks || []).some(d => d && d.sku === 'UltraSSD_LRS'));

    const template = {
      "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
      "contentVersion": "1.0.0.0",
      "parameters": {
        "adminUsername": { "type": "string", "defaultValue": "azureuser" },
        "adminPassword": { "type": "secureString" },
        "ultraAvailabilityZone": {
          "type": "string",
          "defaultValue": "1",
          "allowedValues": ["1", "2", "3"],
          "metadata": {
            "description": "Availability Zone used when UltraSSD_LRS requires zonal placement."
          }
        }
      },
      "variables": {
        "vnetName": "labVnet",
        "subnetName": "default",
        "nsgName": "labNsg",
        "addressPrefix": "10.1.0.0/16",
        "subnetPrefix": "10.1.0.0/24"
      },
      "resources": [],
      "outputs": { "vmFqdns": { "type": "array", "value": [] } }
    };

    if (!hasAnyUltraSsdDataDisk) {
      delete template.parameters.ultraAvailabilityZone;
    }

    template.resources.push({
      "type": "Microsoft.Network/networkSecurityGroups",
      "apiVersion": "2024-05-01",
      "name": "[variables('nsgName')]",
      "location": locationExpr,
      "properties": {
        "securityRules": [
          {
            "name": "inbound_ssh_azurecloud",
            "properties": {
              "access": "Allow",
              "protocol": "Tcp",
              "direction": "Inbound",
              "priority": 100,
              "sourceAddressPrefix": "AzureCloud",
              "sourcePortRange": "*",
              "destinationAddressPrefix": "*",
              "destinationPortRange": "22"
            }
          }
        ]
      }
    });

    template.resources.push({
      "type": "Microsoft.Network/virtualNetworks",
      "apiVersion": "2024-05-01",
      "name": "[variables('vnetName')]",
      "location": locationExpr,
      "properties": { "addressSpace": { "addressPrefixes": ["[variables('addressPrefix')]"] } }
    });

    template.resources.push({
      "type": "Microsoft.Network/virtualNetworks/subnets",
      "apiVersion": "2024-05-01",
      "name": "[format('{0}/{1}', variables('vnetName'), variables('subnetName'))]",
      "dependsOn": [
        "[resourceId('Microsoft.Network/virtualNetworks', variables('vnetName'))]",
        "[resourceId('Microsoft.Network/networkSecurityGroups', variables('nsgName'))]"
      ],
      "properties": {
        "addressPrefix": "[variables('subnetPrefix')]",
        "networkSecurityGroup": { "id": "[resourceId('Microsoft.Network/networkSecurityGroups', variables('nsgName'))]" }
      }
    });

    vms.forEach(vm => {
      const vmName = vm.name;
      const nics = (vm.nics && vm.nics.length) ? vm.nics : [ defaultNic(0) ];
      const allowAccel = accelNetSupportedFor(vm);
      const hasUltraSsdDataDisk = (vm.disks || []).some(d => d && d.sku === 'UltraSSD_LRS');

      // Per NIC: optional PIP + NIC
      nics.forEach(nic => {
        const nicName = `${vmName}-${nic.name}`;
        const pipName = `${vmName}-${nic.name}-pip`;

        if (nic.publicIp) {
          const dnsLabel = `[concat('${vmName}-${nic.name}', uniqueString(resourceGroup().id))]`;
          const pipResource = {
            "type": "Microsoft.Network/publicIPAddresses",
            "apiVersion": "2024-05-01",
            "name": pipName,
            "location": locationExpr,
            "sku": { "name": "Standard" },
            "properties": {
              "publicIPAllocationMethod": "Static",
              "publicIPAddressVersion": "IPv4",
              "dnsSettings": { "domainNameLabel": dnsLabel }
            }
          };
          // Ultra disks require zonal VM placement for these sizes; keep PIP aligned.
          if (hasUltraSsdDataDisk) pipResource.zones = ["[parameters('ultraAvailabilityZone')]"];
          template.resources.push(pipResource);
          template.outputs.vmFqdns.value.push(
            `[reference(resourceId('Microsoft.Network/publicIPAddresses', '${pipName}')).dnsSettings.fqdn]`
          );
        }

        const nicDepends = ["[resourceId('Microsoft.Network/virtualNetworks/subnets', variables('vnetName'), variables('subnetName'))]"];
        if (nic.publicIp) nicDepends.unshift(`[resourceId('Microsoft.Network/publicIPAddresses', '${pipName}')]`);

        const ipconfigProps = {
          "subnet": { "id": "[resourceId('Microsoft.Network/virtualNetworks/subnets', variables('vnetName'), variables('subnetName'))]" },
          "privateIPAllocationMethod": "Dynamic"
        };
        if (nic.publicIp) ipconfigProps.publicIPAddress = { "id": `[resourceId('Microsoft.Network/publicIPAddresses', '${pipName}')]` };

        template.resources.push({
          "type": "Microsoft.Network/networkInterfaces",
          "apiVersion": "2024-05-01",
          "name": nicName,
          "location": locationExpr,
          "dependsOn": nicDepends,
          "properties": {
            "enableAcceleratedNetworking": allowAccel ? resolvedAccelForNic(vm, nic) : false,
            "ipConfigurations": [ { "name": "ipconfig1", "properties": ipconfigProps } ]
          }
        });
      });

      const vmNicRefs = nics.map((nic, idx) => ({
        "id": `[resourceId('Microsoft.Network/networkInterfaces', '${vmName}-${nic.name}')]`,
        "properties": { "primary": idx === 0 }
      }));

      const vmDepends = nics.map(nic => `[resourceId('Microsoft.Network/networkInterfaces', '${vmName}-${nic.name}')]`);
      const selectedImage = imageByKey(vm.imageKey);
      const selectedImageGen = selectedImage ? selectedImage.gen : vm.gen;
      const customDataRaw = String(vm.customData || '');
      const encodedCustomData = encodeCustomDataForArm(customDataRaw, !!vm.rebootRequired);

      const storageProfile = {
        "imageReference": imageMap[vm.imageKey],
        "osDisk": { "createOption": "FromImage", "managedDisk": { "storageAccountType": "StandardSSD_LRS" } },
        "dataDisks": (vm.disks || []).map((d, lun) => ({
          "lun": lun,
          "createOption": "Empty",
          "diskSizeGB": d.sizeGB,
          "managedDisk": { "storageAccountType": d.sku }
        }))
      };
      // diskControllerType is valid only for Generation 2 VM/image combinations.
      if (vm.diskControllerType && vm.gen === 'Gen2' && selectedImageGen === 'Gen2') {
        storageProfile.diskControllerType = vm.diskControllerType;
      }

      const osProfile = {
        "computerName": vmName,
        "adminUsername": "[parameters('adminUsername')]",
        "adminPassword": "[parameters('adminPassword')]"
      };
      if (encodedCustomData) osProfile.customData = encodedCustomData;

      const vmProperties = {
        "hardwareProfile": { "vmSize": vm.size },
        "storageProfile": storageProfile,
        "networkProfile": { "networkInterfaces": vmNicRefs },
        "osProfile": osProfile,
        "diagnosticsProfile": { "bootDiagnostics": { "enabled": true } }
      };
      if (hasUltraSsdDataDisk) {
        vmProperties.additionalCapabilities = { "ultraSSDEnabled": true };
      }

      const vmResource = {
        "type": "Microsoft.Compute/virtualMachines",
        "apiVersion": "2023-03-01",
        "name": vmName,
        "location": locationExpr,
        "dependsOn": vmDepends,
        "properties": vmProperties
      };
      // Ultra disks require a zonal VM for these SKUs (1/2/3). Default to zone 1.
      if (hasUltraSsdDataDisk) vmResource.zones = ["[parameters('ultraAvailabilityZone')]"];

      template.resources.push(vmResource);
    });

    return template;
  }

  // -----------------------------
  // UI rendering and interaction
  // -----------------------------
  const el = (id) => document.getElementById(id);
  /** @deprecated Alias kept for brevity  prefer el() for clarity. */
  const $ = el;

  function ensureNic(vm) {
    if (!vm.nics || vm.nics.length === 0) vm.nics = [ defaultNic(0) ];
  }

  function renderTabs() {
    const tabsEl = $('tabs');
    tabsEl.innerHTML = '';
    vms.forEach((vm, idx) => {
      const b = document.createElement('button');
      b.className = 'tab' + (idx === active ? ' active' : '');
      b.textContent = vm.name || `vm${idx+1}`;
      b.setAttribute('role', 'tab');
      b.setAttribute('aria-selected', String(idx === active));
      b.tabIndex = idx === active ? 0 : -1;
      b.onclick = () => { active = idx; render(); };
      b.onkeydown = (e) => {
        let next = -1;
        if (e.key === 'ArrowRight') next = (idx + 1) % vms.length;
        else if (e.key === 'ArrowLeft') next = (idx - 1 + vms.length) % vms.length;
        else if (e.key === 'Home') next = 0;
        else if (e.key === 'End') next = vms.length - 1;
        if (next < 0) return;
        e.preventDefault();
        active = next;
        render();
        const nextBtn = tabsEl.children[next];
        if (nextBtn) nextBtn.focus();
      };
      tabsEl.appendChild(b);
    });
    $('removeVmBtn').disabled = vms.length <= 1;
  }

  function setSelectOptions(selectEl, values, labelsByValue) {
    if (!selectEl) return;
    selectEl.innerHTML = '';
    values.forEach(v => {
      const o = document.createElement('option');
      o.value = v;
      o.textContent = (labelsByValue && labelsByValue[v]) ? labelsByValue[v] : v;
      selectEl.appendChild(o);
    });
  }

  function renderSizeFilterPanelFields() {
    const grid = $('sizeFilterGrid');
    if (!grid) return;
    grid.innerHTML = '';

    Object.keys(sizeFilterMeta).forEach((key) => {
      const meta = sizeFilterMeta[key];
      const item = document.createElement('div');
      item.className = 'size-filter-item';

      const label = document.createElement('label');
      label.textContent = meta.label;

      const sel = document.createElement('select');
      sel.setAttribute('data-filter-key', key);

      const labels = { '': 'Any' };
      (meta.values || []).forEach(v => {
        labels[v] = (meta.valueLabels && meta.valueLabels[v]) ? meta.valueLabels[v] : v;
      });
      setSelectOptions(sel, [''].concat(meta.values || []), labels);
      sel.value = sizeFilters[key] || '';

      item.appendChild(label);
      item.appendChild(sel);
      grid.appendChild(item);
    });
  }

  function renderSizeFilterChips() {
    const chips = $('sizeFilterChips');
    if (!chips) return;
    chips.innerHTML = '';

    const activeFilterKeys = Object.keys(sizeFilterMeta).filter(k => !!sizeFilters[k]);
    activeFilterKeys.forEach(k => {
      const meta = sizeFilterMeta[k];
      const raw = sizeFilters[k];
      const shown = (meta.valueLabels && meta.valueLabels[raw]) ? meta.valueLabels[raw] : raw;
      const chip = document.createElement('button');
      chip.type = 'button';
      chip.className = 'chip-btn';
      chip.setAttribute('data-filter-key', k);
      chip.innerHTML = `${meta.label}: ${shown} <span class="x"></span>`;
      chips.appendChild(chip);
    });

    if (!activeFilterKeys.length) {
      const muted = document.createElement('span');
      muted.className = 'muted';
      muted.style.marginTop = '0';
      muted.textContent = 'No active filters';
      chips.appendChild(muted);
    }

    renderSizeFilterPanelFields();

    // Announce filter result count to screen readers
    const liveEl = $('sizeFilterLive');
    if (liveEl) {
      const count = filteredSizeOptions().length;
      const total = sizeOptions.length;
      liveEl.textContent = activeFilterKeys.length
        ? `${count} of ${total} VM size${count !== 1 ? 's' : ''} match${count === 1 ? 'es' : ''} current filters.`
        : '';
    }
  }

  function alignVmSizeToActiveFilters(vm) {
    const filtered = filteredSizeOptions();
    if (!vm || !filtered.length) return;
    if (!filtered.some(s => s.name === vm.size)) {
      vm.size = filtered[0].name;
    }
  }

  function populateSizeSelect(vm) {
    const sel = $('vmSize');
    sel.innerHTML = '';
    const list = filteredSizeOptions();

    list.forEach(s => {
      const o = document.createElement('option');
      o.value = s.name;
      o.textContent = s.name;
      sel.appendChild(o);
    });

    if (!list.length) {
      const o = document.createElement('option');
      o.value = '';
      o.textContent = 'No VM sizes match filters';
      sel.appendChild(o);
      sel.value = '';
      sel.disabled = true;
      return;
    }

    sel.disabled = false;
    if (vm && list.some(s => s.name === vm.size)) {
      sel.value = vm.size;
    }
  }

  function populateGenSelect(vm) {
    const sel = $('vmGen');
    sel.innerHTML = '';
    const allowed = allowedGenerationsFor(vm);
    allowed.forEach(g => {
      const o = document.createElement('option');
      o.value = g;
      o.textContent = g;
      sel.appendChild(o);
    });
    if (!allowed.includes(vm.gen)) vm.gen = allowed[0];
    sel.value = vm.gen;
    sel.disabled = allowed.length <= 1;
  }

  function populateControllerSelect(vm) {
    const sel = $('diskController');
    sel.innerHTML = '';
    const allowed = allowedControllersFor(vm);
    allowed.forEach(c => {
      const o = document.createElement('option');
      o.value = c;
      o.textContent = c;
      sel.appendChild(o);
    });
    if (!allowed.includes(vm.diskControllerType)) vm.diskControllerType = allowed[0];
    sel.value = vm.diskControllerType;
    sel.disabled = allowed.length <= 1;
  }

  function populatePublisherSelect(vm) {
    const sel = $('vmPublisher');
    if (!sel) return;
    sel.innerHTML = '';
    const pubs = publishersFor(vm);

    const all = document.createElement('option');
    all.value = '';
    all.textContent = 'All publishers';
    sel.appendChild(all);

    pubs.forEach(p => {
      const o = document.createElement('option');
      o.value = p;
      o.textContent = p;
      sel.appendChild(o);
    });

    if (vm.publisherFilter && !pubs.includes(vm.publisherFilter)) vm.publisherFilter = '';
    sel.value = vm.publisherFilter || '';
  }

  function populateImageSelect(vm) {
    const sel = $('vmImage');
    sel.innerHTML = '';
    const imgs = filterImagesFor(vm);
    imgs.forEach(img => {
      const o = document.createElement('option');
      o.value = img.key;
      o.textContent = img.label;
      sel.appendChild(o);
    });
    if (!imgs.find(i => i.key === vm.imageKey)) vm.imageKey = imgs[0] ? imgs[0].key : '';
    sel.value = vm.imageKey;
  }

  function renderHints(vm) {
    const hintEl = $('sizeHint');
    const sz = sizeByName(vm.size);
    const accelMode = accelNetModeFor(vm);
    const accelText = accelMode === 'required' ? 'Required' : (accelMode === 'unsupported' ? 'Not supported' : 'Supported (optional)');
    const hasMatchingSizes = filteredSizeOptions().length > 0;
    const currentSizeMatches = !sizeIsOutsideFilters(vm.size);

    if (!hasMatchingSizes) {
      if (hintEl) {
        hintEl.style.display = '';
        hintEl.textContent = 'No VM size matches the filters.';
      }
    } else if (!currentSizeMatches) {
      if (hintEl) {
        hintEl.textContent = '';
        hintEl.style.display = 'none';
      }
    } else if (hintEl) {
      hintEl.style.display = '';
      hintEl.textContent = `Supports: Arch ${allowedArchitecturesFor(vm).join('/')} | ${sz.tags.generations.join(', ')} | DiskCtl (for ${vm.gen}): ${allowedControllersFor(vm).join(', ')} | AccelNet: ${accelText} | Max NICs: ${maxNicsFor(vm)} | Max Data Disks: ${maxDataDisksFor(vm)}`;
    }

    const imgs = filterImagesFor(vm);
    const notes = [];
    const allowedCtl = allowedControllersFor(vm);
  if (allowedCtl.length === 1 && allowedCtl[0] === 'NVMe') {
      notes.push('NVMe-only size: images must be NVMe-tagged (verify with az vm image show).');
    }
    $('imageHint').textContent = imgs.length ? notes.join(' ') : 'No images match this size. Add more image mappings or relax filters.';
  }

  function renderVmSummaryTable() {
    const host = $('vmSummary');
    if (!host) return;

    const esc = (v) => String(v ?? '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    const td = (v) => {
      const t = String(v ?? '-');
      return `<td><span class="truncate-cell" title="${esc(t)}">${esc(t)}</span></td>`;
    };

    if (!vms.length) {
      host.innerHTML = '<div class="muted">No VMs defined.</div>';
      return;
    }

    const rows = vms.map(vm => {
      const img = imageByKey(vm.imageKey);
      const nicCount = (vm.nics || []).length;
      const publicIps = (vm.nics || []).filter(n => !!n.publicIp).length;
      const diskCount = (vm.disks || []).length;
      return `<tr>
        ${td(vm.name)}
        ${td(vm.size)}
        ${td(img ? img.label : '-')}
        ${td(vm.diskControllerType || '-')}
        ${td(`${nicCount} (Public IPs: ${publicIps})`)}
        ${td(String(diskCount))}
      </tr>`;
    }).join('');

    host.innerHTML = `<table class="summary">
      <thead>
        <tr>
          <th>VM Name</th>
          <th>VM Size</th>
          <th>Image</th>
          <th>Disk Controller</th>
          <th>NICs</th>
          <th>Data Disks</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>`;
  }

  function renderNics(vm) {
    ensureNic(vm);
    const list = $('nicList');
    list.innerHTML = '';
    const nics = vm.nics || [];
    $('noNicMsg').style.display = nics.length ? 'none' : 'block';
    const nicLimitErr = nicAttachmentCountError(vm);

    const allowAccel = accelNetSupportedFor(vm);
    const requireAccel = accelNetRequiredFor(vm);

    nics.forEach((nic, idx) => {
      const box = document.createElement('div');
      box.className = 'box';

      const header = document.createElement('div');
      header.className = 'row';
      const headerLeft = document.createElement('div');
      const headerStrong = document.createElement('strong');
      headerStrong.textContent = String(nic.name || '');
      const headerMuted = document.createElement('span');
      headerMuted.className = 'muted';
      headerMuted.textContent = idx === 0 ? '(primary)' : '';
      headerLeft.appendChild(headerStrong);
      headerLeft.appendChild(document.createTextNode(' '));
      headerLeft.appendChild(headerMuted);
      header.appendChild(headerLeft);

      const rm = document.createElement('button');
      rm.className = 'danger';
      rm.textContent = 'Remove NIC';
      rm.disabled = nics.length <= 1;
      rm.onclick = () => { vm.nics.splice(idx, 1); renderNics(vm); updateNicDiskButtons(vm); updateOutput(); };
      header.appendChild(rm);

      const grid = document.createElement('div');
      grid.className = 'grid3';

      const nameWrap = document.createElement('div');
      const nicErrText = nicNameError(vm, nic);
      const nicMaxLen = nicNameMaxLengthForVmName(vm.name);
      const nameLabel = document.createElement('label');
      nameLabel.textContent = 'NIC Name';
      const nameInput = document.createElement('input');
      nameInput.value = String(nic.name || '');
      nameInput.maxLength = nicMaxLen;
      nameWrap.appendChild(nameLabel);
      nameWrap.appendChild(nameInput);
      nameInput.oninput = (e) => {
        nic.name = (e.target.value || '').trim() || nextDefaultNicName(vm);

        const errText = nicNameError(vm, nic);
        const errEl = box.querySelector('.nic-line-error');
        if (errEl) {
          errEl.textContent = errText;
          errEl.style.display = errText ? 'block' : 'none';
        }
        const fixEl = box.querySelector('.nic-line-fix');
        if (fixEl) fixEl.style.display = errText ? 'block' : 'none';

        renderTabs();
        updateOutput();
      };

      const accWrap = document.createElement('div');
      if (!allowAccel) {
        nic.accelerated = false;
        accWrap.innerHTML = `<label>Accelerated Networking</label>
          <div class="muted">Not supported for this VM size.</div>`;
      } else {
        if (requireAccel) nic.accelerated = true;
        accWrap.innerHTML = `<label>Accelerated Networking</label>
          <div class="toggle"><input type="checkbox" ${resolvedAccelForNic(vm, nic) ? 'checked' : ''} ${requireAccel ? 'disabled' : ''} /> <span class="muted">${requireAccel ? 'Required by selected VM size' : 'enableAcceleratedNetworking'}</span></div>`;
        const accCb = accWrap.querySelector('input');
        if (accCb) accCb.onchange = (e) => { nic.accelerated = requireAccel ? true : !!e.target.checked; updateOutput(); };
      }

      const pipWrap = document.createElement('div');
      pipWrap.innerHTML = `<label>Public IP</label>
        <div class="toggle"><input type="checkbox" ${nic.publicIp ? 'checked' : ''} /> <span class="muted">create Public IP + DNS</span></div>`;
      pipWrap.querySelector('input').onchange = (e) => { nic.publicIp = !!e.target.checked; updateOutput(); };

      grid.appendChild(nameWrap);
      grid.appendChild(accWrap);
      grid.appendChild(pipWrap);

      box.appendChild(header);
      box.appendChild(grid);
      const lineError = document.createElement('div');
      lineError.className = 'error-text nic-line-error';
      lineError.textContent = nicErrText;
      lineError.style.display = nicErrText ? 'block' : 'none';
      box.appendChild(lineError);
      const lineFix = document.createElement('div');
      lineFix.className = 'error-text nic-line-fix';
      lineFix.textContent = 'Fix NIC name errors before generating the ARM template.';
      lineFix.style.display = nicErrText ? 'block' : 'none';
      box.appendChild(lineFix);
      list.appendChild(box);
    });

    if (nicLimitErr) {
      const limitErr = document.createElement('div');
      limitErr.className = 'error-text';
      limitErr.textContent = nicLimitErr;
      list.appendChild(limitErr);
    }
  }

  function renderDisks(vm) {
    const diskList = $('diskList');
    diskList.innerHTML = '';
    const disks = vm.disks || [];
    const supportedSkus = supportedDiskSkusFor(vm);
    $('noDiskMsg').style.display = disks.length ? 'none' : 'block';
    const diskLimitErr = diskAttachmentCountError(vm);

    disks.forEach((d, di) => {
      const box = document.createElement('div');
      box.className = 'box';
      const diskErrText = diskSizeError(d);

      const grid = document.createElement('div');
      grid.className = 'grid3';

      const sizeWrap = document.createElement('div');
      sizeWrap.innerHTML = `<label>Size (GB)</label><input type="number" min="2" value="${d.sizeGB}" />`;
      sizeWrap.querySelector('input').oninput = (e) => {
        d.sizeGB = Number(e.target.value || 0);
        const errText = diskSizeError(d);
        const errEl = box.querySelector('.disk-line-error');
        if (errEl) {
          errEl.textContent = errText;
          errEl.style.display = errText ? 'block' : 'none';
        }
        const fixEl = box.querySelector('.disk-line-fix');
        if (fixEl) fixEl.style.display = errText ? 'block' : 'none';
        updateOutput();
      };

      const skuWrap = document.createElement('div');
      const skuSel = document.createElement('select');
      supportedSkus.forEach(s => { const o = document.createElement('option'); o.value = s; o.textContent = s; skuSel.appendChild(o); });
      if (!supportedSkus.includes(d.sku)) d.sku = defaultDiskSkuFor(vm);
      skuSel.value = d.sku;
      skuSel.onchange = (e) => {
        d.sku = e.target.value;
        const errText = diskSizeError(d);
        const errEl = box.querySelector('.disk-line-error');
        if (errEl) {
          errEl.textContent = errText;
          errEl.style.display = errText ? 'block' : 'none';
        }
        const fixEl = box.querySelector('.disk-line-fix');
        if (fixEl) fixEl.style.display = errText ? 'block' : 'none';
        updateOutput();
      };
      skuWrap.appendChild(document.createElement('label')).textContent = 'SKU';
      skuWrap.appendChild(skuSel);

      const rmBtn = document.createElement('button');
      rmBtn.className = 'danger';
      rmBtn.textContent = 'Remove';
      rmBtn.onclick = () => { disks.splice(di, 1); renderDisks(vm); updateNicDiskButtons(vm); updateOutput(); };

      grid.appendChild(sizeWrap);
      grid.appendChild(skuWrap);
      grid.appendChild(rmBtn);

      box.appendChild(grid);
      const lineError = document.createElement('div');
      lineError.className = 'error-text disk-line-error';
      lineError.textContent = diskErrText;
      lineError.style.display = diskErrText ? 'block' : 'none';
      box.appendChild(lineError);

      const lineFix = document.createElement('div');
      lineFix.className = 'error-text disk-line-fix';
      lineFix.textContent = 'Fix data disk validation errors before generating the ARM template.';
      lineFix.style.display = diskErrText ? 'block' : 'none';
      box.appendChild(lineFix);

      diskList.appendChild(box);
    });

    if (diskLimitErr) {
      const limitErr = document.createElement('div');
      limitErr.className = 'error-text';
      limitErr.textContent = diskLimitErr;
      diskList.appendChild(limitErr);
    }
  }

  function sanitizeVm(vm, idx) {
    // Single-VM normalization pass.
    // This function is intentionally defensive and is called frequently before render/output.
    vm.name = (vm.name || `vm${idx+1}`).trim() || `vm${idx+1}`;
    vm.customData = String(vm.customData || '');
    vm.rebootRequired = !!vm.rebootRequired;
    vm.publisherFilter = String(vm.publisherFilter || '');
    ensureNic(vm);
    vm.nics.forEach((n, i) => { n.name = (n.name || `nic${i+1}`).trim() || `nic${i+1}`; });

    const gens = allowedGenerationsFor(vm);
    if (!gens.includes(vm.gen)) vm.gen = gens[0];

    const ctls = allowedControllersFor(vm);
    if (!ctls.includes(vm.diskControllerType)) vm.diskControllerType = ctls[0];

    if (accelNetRequiredFor(vm)) vm.nics.forEach(n => n.accelerated = true);
    else if (!accelNetSupportedFor(vm)) vm.nics.forEach(n => n.accelerated = false);

    normalizeDataDiskSkus(vm);

    let imgs = filterImagesFor(vm);
    if (!imgs.length && vm.publisherFilter) {
      vm.publisherFilter = '';
      imgs = filterImagesFor(vm);
    }
    if (!imgs.find(i => i.key === vm.imageKey)) vm.imageKey = imgs[0] ? imgs[0].key : '';

    return vm;
  }

  function invalidateCycleCaches() {
    // Clear per-cycle caches so the next computation picks up fresh data.
    state._imageCache = null;
    state._dupVmNamesCache = null;
  }

  function sanitizeAllVms() {
    // Global normalization pass.
    vms.forEach((vm, idx) => sanitizeVm(vm, idx));
  }

  function updateOutput() {
    // Main recompute step after any user change:
    // sanitize -> validate names -> generate ARM -> update textarea + summary.
    invalidateCycleCaches();
    sanitizeAllVms();
    saveUiState();
    renderVmSummaryTable();

    const hasVmNameErrors = hasAnyVmNameErrors();
    const hasNicNameErrors = hasAnyNicNameErrors();
    const hasDiskErrors = hasAnyDiskValidationErrors();
    const hasAttachmentErrors = hasAnyAttachmentLimitErrors();
    const hasValidationErrors = hasVmNameErrors || hasNicNameErrors || hasDiskErrors || hasAttachmentErrors;

    $('copyBtn').disabled = hasValidationErrors;
    $('deployPortalBtn').disabled = hasValidationErrors;
    $('downloadBtn').disabled = hasValidationErrors;
    if (hasValidationErrors) {
      if (hasAttachmentErrors) {
        $('output').value = 'Fix VM size attachment limit errors (NIC/data disk counts) before generating the ARM template.';
      } else if (hasVmNameErrors && hasNicNameErrors && hasDiskErrors) {
        $('output').value = 'Fix VM, NIC, and data disk validation errors before generating the ARM template.';
      } else if (hasVmNameErrors && hasNicNameErrors) {
        $('output').value = 'Fix VM and NIC name errors before generating the ARM template.';
      } else if (hasVmNameErrors && hasDiskErrors) {
        $('output').value = 'Fix VM name and data disk validation errors before generating the ARM template.';
      } else if (hasNicNameErrors && hasDiskErrors) {
        $('output').value = 'Fix NIC and data disk validation errors before generating the ARM template.';
      } else if (hasVmNameErrors) {
        $('output').value = 'Fix VM name errors before generating the ARM template.';
      } else if (hasDiskErrors) {
        $('output').value = 'Fix data disk validation errors in the VM settings panel before generating the ARM template.';
      } else {
        $('output').value = 'Fix NIC validation errors in the VM settings panel before generating the ARM template.';
      }
      return;
    }

    const arm = generateArmTemplate(vms);
    $('output').value = JSON.stringify(arm, null, 2);
  }

  // ---------------------------------------------------------------------------
  // Targeted render helpers (avoid full DOM teardown for every interaction)
  // ---------------------------------------------------------------------------

  function renderVmFormFields(vm) {
    // Update simple form field values  no DOM creation/destruction.
    $('vmMeta').textContent = `VM ${active + 1} of ${vms.length}`;
    $('vmName').value = vm.name;
    const nameErr = $('vmNameError');
    if (nameErr) nameErr.textContent = vmNameErrorAt(active);
    $('vmCustomData').value = vm.customData || '';
    $('vmRebootRequired').checked = !!vm.rebootRequired;
    $('vmSize').value = vm.size;
    updateNicDiskButtons(vm);
  }

  function renderVmSelects(vm) {
    // Repopulate the generation / controller / publisher / image dropdowns.
    populateGenSelect(vm);
    populateControllerSelect(vm);
    populatePublisherSelect(vm);
    populateImageSelect(vm);
  }

  function updateNicDiskButtons(vm) {
    // Refresh the Add NIC / Add Disk button disabled state.
    $('addNicBtn').disabled = (vm.nics || []).length >= maxNicsFor(vm);
    $('addDiskBtn').disabled = (vm.disks || []).length >= maxDataDisksFor(vm);
  }

  function updateNicNameConstraints(vm) {
    // Patch NIC-name maxLength + error text in-place (avoids full NIC DOM rebuild).
    const maxLen = nicNameMaxLengthForVmName(vm.name);
    $('nicList').querySelectorAll('.box').forEach((box, idx) => {
      const nameInput = box.querySelector('.grid3 > div:first-child input');
      if (nameInput) nameInput.maxLength = maxLen;
      const nic = (vm.nics || [])[idx];
      if (nic) {
        const errText = nicNameError(vm, nic);
        const errEl = box.querySelector('.nic-line-error');
        if (errEl) { errEl.textContent = errText; errEl.style.display = errText ? 'block' : 'none'; }
        const fixEl = box.querySelector('.nic-line-fix');
        if (fixEl) fixEl.style.display = errText ? 'block' : 'none';
      }
    });
  }

  // ---------------------------------------------------------------------------
  // Import ARM JSON  populate tool (best-effort, catalog-constrained)
  // ---------------------------------------------------------------------------
  function importFromArmJson(jsonText) {
    let template;
    try {
      template = JSON.parse(jsonText);
    } catch (e) {
      showToast('Import failed', 'The file is not valid JSON.');
      return;
    }

    const resources = template && template.resources;
    if (!Array.isArray(resources)) {
      showToast('Import failed', 'No "resources" array found in the JSON.');
      return;
    }

    // --- Collect NIC resources by name for later lookup ---
    const nicResources = new Map();
    resources.filter(r => r.type === 'Microsoft.Network/networkInterfaces').forEach(r => {
      nicResources.set(r.name, r);
    });

    // --- Collect PIP resource names for detecting publicIp ---
    const pipNames = new Set(
      resources.filter(r => r.type === 'Microsoft.Network/publicIPAddresses').map(r => r.name)
    );

    // --- Helper: resolve ARM resourceId reference to a plain name ---
    function extractNameFromResourceId(idExpr) {
      // Handles: "[resourceId('Microsoft.Network/networkInterfaces', 'vm1-nic1')]"
      const m = String(idExpr || '').match(/resourceId\([^,]+,\s*'([^']+)'\)/);
      return m ? m[1] : '';
    }

    // --- Helper: match an imageReference to our catalog ---
    function matchImage(imgRef) {
      if (!imgRef) return null;
      const pub = String(imgRef.publisher || '').toLowerCase();
      const off = String(imgRef.offer || '').toLowerCase();
      const sk  = String(imgRef.sku || '').toLowerCase();
      // Exact match on publisher + offer + sku
      return imageOptions.find(opt => {
        const r = opt.ref || {};
        return String(r.publisher || '').toLowerCase() === pub
            && String(r.offer    || '').toLowerCase() === off
            && String(r.sku      || '').toLowerCase() === sk;
      }) || null;
    }

    // --- Helper: match a vmSize to our catalog ---
    function matchSize(vmSizeName) {
      const lower = String(vmSizeName || '').toLowerCase();
      return sizeOptions.find(s => s.name.toLowerCase() === lower) || null;
    }

    // --- Extract VM resources ---
    const vmResources = resources.filter(r => r.type === 'Microsoft.Compute/virtualMachines');
    if (!vmResources.length) {
      showToast('Import failed', 'No Microsoft.Compute/virtualMachines resources found.');
      return;
    }

    const imported = [];
    const skipped = [];

    vmResources.forEach(vmRes => {
      const props = vmRes.properties || {};
      const vmName = String(vmRes.name || '').replace(/^\[|\]$/g, '').trim();

      // --- VM Size ---
      const rawSize = (props.hardwareProfile && props.hardwareProfile.vmSize) || '';
      const sizeMatch = matchSize(rawSize);
      if (!sizeMatch) {
        skipped.push(`${vmName || '(unnamed)'}: size '${rawSize}' not in catalog`);
        return;
      }

      // --- Image ---
      const imgRef = (props.storageProfile && props.storageProfile.imageReference) || {};
      const imageMatch = matchImage(imgRef);
      if (!imageMatch) {
        skipped.push(`${vmName}: image '${imgRef.publisher || ''}:${imgRef.offer || ''}:${imgRef.sku || ''}' not in catalog`);
        return;
      }

      // --- Disk controller ---
      const rawController = (props.storageProfile && props.storageProfile.diskControllerType) || '';
      const validControllers = ['SCSI', 'NVMe'];
      const diskControllerType = validControllers.includes(rawController) ? rawController : 'SCSI';

      // --- Generation (from matched image) ---
      const gen = imageMatch.gen || 'Gen2';

      // --- Custom data (cleared on import  round-trip decoding not guaranteed safe) ---
      const customData = '';

      // --- Reboot flag (can't be inferred from ARM, default false) ---
      const rebootRequired = false;

      // --- NICs ---
      const nicRefs = (props.networkProfile && props.networkProfile.networkInterfaces) || [];
      const nics = [];
      nicRefs.forEach((nicRef, idx) => {
        const fullNicName = extractNameFromResourceId(nicRef.id);
        // Derive the short NIC name by stripping the VM name prefix
        let shortName = fullNicName;
        if (fullNicName.toLowerCase().startsWith(vmName.toLowerCase() + '-')) {
          shortName = fullNicName.slice(vmName.length + 1);
        }

        // Check if this NIC has a public IP
        const nicRes = nicResources.get(fullNicName);
        let hasPublicIp = false;
        if (nicRes) {
          const ipConfigs = (nicRes.properties && nicRes.properties.ipConfigurations) || [];
          hasPublicIp = ipConfigs.some(ipc => {
            const ipcProps = ipc.properties || {};
            if (ipcProps.publicIPAddress) {
              const pipId = ipcProps.publicIPAddress.id || '';
              const pipName = extractNameFromResourceId(pipId);
              return pipNames.has(pipName);
            }
            return false;
          });
        }

        // Check accelerated networking
        const accel = nicRes && nicRes.properties && !!nicRes.properties.enableAcceleratedNetworking;

        nics.push({
          id: uid(),
          name: shortName || `nic${idx + 1}`,
          accelerated: accel,
          publicIp: hasPublicIp
        });
      });
      // (nicRefs already ordered by ARM with primary first, but just in case)

      // --- Data disks ---
      const rawDisks = (props.storageProfile && props.storageProfile.dataDisks) || [];
      const validDiskSkus = Object.keys(maxDiskSizeGbBySku);
      const disks = rawDisks.map(d => {
        const rawSku = (d.managedDisk && d.managedDisk.storageAccountType) || '';
        const sku = validDiskSkus.includes(rawSku) ? rawSku : 'StandardSSD_LRS';
        return {
          sizeGB: Number(d.diskSizeGB) || LIMITS.DEFAULT_DATA_DISK_GB,
          sku: sku
        };
      });

      imported.push({
        id: uid(),
        name: vmName || `vm${imported.length + 1}`,
        size: sizeMatch.name,
        gen: gen,
        imageKey: imageMatch.key,
        diskControllerType: diskControllerType,
        publisherFilter: '',
        customData: customData,
        rebootRequired: rebootRequired,
        nics: nics.length ? nics : [defaultNic(0)],
        disks: disks
      });
    });

    if (!imported.length) {
      showToast('Import: nothing imported', `All ${vmResources.length} VM(s) skipped: ${skipped.join('; ')}`);
      return;
    }

    // Replace current VMs with imported ones
    state.vms = imported;
    state.activeVmIndex = 0;
    render();

    // Build summary
    const parts = [`Imported ${imported.length} VM(s).`];
    if (skipped.length) parts.push(`Skipped ${skipped.length}: ${skipped.join('; ')}`);
    if (vmResources.some(r => (r.properties && r.properties.osProfile && r.properties.osProfile.customData))) {
      parts.push('Custom data was cleared (cannot reverse-decode).');
    }
    showToast('Import complete', parts.join(' '));
  }

  function render() {
    // Full UI render pipeline  use for tab switches, add/remove VM, initial load.
    // For partial updates prefer the targeted helpers above.
    invalidateCycleCaches();
    renderSizeFilterChips();
    renderTabs();

    const vm = vms[active];

    alignVmSizeToActiveFilters(vm);
    sanitizeVm(vm, active);

    populateSizeSelect(vm);
    renderVmFormFields(vm);
    renderVmSelects(vm);
    renderHints(vm);
    renderNics(vm);
    renderDisks(vm);

    updateOutput();
  }

  // ---------------------------------------------------------------------------
  // Event wiring (mutations happen here, then render()/updateOutput() keeps UI consistent)
  // ---------------------------------------------------------------------------
  // Pattern:
  // - mutate active VM model
  // - auto-correct incompatible fields when needed
  // - optionally show toast for user awareness
  // - call render() (full refresh) or updateOutput() (cheap refresh)
  // ---------------------------------------------------------------------------
  // Events
  // --- Filter panel helpers (open / close / focus-trap) ---
  function openFilterPanel() {
    const p = $('sizeFilterPanel');
    if (!p) return;
    renderSizeFilterPanelFields();
    p.style.display = 'block';
    const first = p.querySelector('select, button, input');
    if (first) first.focus();
  }
  function closeFilterPanel(returnFocus) {
    const p = $('sizeFilterPanel');
    if (p) p.style.display = 'none';
    if (returnFocus) $('addSizeFilterBtn').focus();
  }
  function filterPanelIsOpen() {
    const p = $('sizeFilterPanel');
    return p && p.style.display !== 'none';
  }
  // Focus trap: keep Tab cycling inside the open panel
  $('sizeFilterPanel').addEventListener('keydown', (e) => {
    if (e.key === 'Escape') { closeFilterPanel(true); return; }
    if (e.key !== 'Tab') return;
    const panel = $('sizeFilterPanel');
    const focusable = panel.querySelectorAll('select, button, input, [tabindex]:not([tabindex="-1"])');
    if (!focusable.length) return;
    const first = focusable[0];
    const last = focusable[focusable.length - 1];
    if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
    else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
  });

  $('addSizeFilterBtn').onclick = () => {
    filterPanelIsOpen() ? closeFilterPanel(false) : openFilterPanel();
  };
  $('sizeFilterOkBtn').onclick = () => {
    const grid = $('sizeFilterGrid');
    if (grid) {
      grid.querySelectorAll('select[data-filter-key]').forEach((sel) => {
        const key = sel.getAttribute('data-filter-key');
        if (!key) return;
        sizeFilters[key] = sel.value || '';
      });
    }
    closeFilterPanel(true);
    render();
  };
  $('sizeFilterCancelBtn').onclick = () => {
    closeFilterPanel(true);
  };
  document.addEventListener('click', (e) => {
    const panel = $('sizeFilterPanel');
    const wrap = document.querySelector('.size-filter-wrap');
    if (!panel || !wrap) return;
    if (!wrap.contains(e.target)) closeFilterPanel(false);
  });
  $('sizeFilterChips').onclick = (e) => {
    const btn = e.target.closest('[data-filter-key]');
    if (!btn) return;
    const key = btn.getAttribute('data-filter-key');
    if (!key) return;
    sizeFilters[key] = '';
    render();
  };
  $('clearSizeFiltersBtn').onclick = () => {
    sizeFilters.family = '';
    sizeFilters.arch = '';
    sizeFilters.gen = '';
    sizeFilters.controller = '';
    sizeFilters.diskSku = '';
    sizeFilters.accel = '';
    sizeFilters.ephemeral = '';
    sizeFilters.minNics = '';
    sizeFilters.minDataDisks = '';
    render();
  };

  $('addVmBtn').onclick = () => {
    const vmName = nextDefaultVmName();
    const filtered = filteredSizeOptions();
    const defaultSize = (filtered[0] || sizeOptions[0]).name;
    const vm = {
      id: uid(),
      name: vmName,
      size: defaultSize,
      gen: allowedGenerationsFor({size: defaultSize})[0],
      imageKey: '',
      diskControllerType: allowedControllersFor({size: defaultSize})[0],
      publisherFilter: '',
      customData: '',
      rebootRequired: false,
      nics: [ defaultNic(0) ],
      disks: []
    };
    const imgs = filterImagesFor(vm);
    vm.imageKey = imgs[0] ? imgs[0].key : '';
    vms.push(vm);
    active = vms.length - 1;
    render();
  };

  $('cloneVmBtn').onclick = () => {
    const src = vms[active];
    if (!src) return;

    const clone = {
      ...src,
      id: uid(),
      name: nextCloneVmName(src.name),
      publisherFilter: String(src.publisherFilter || ''),
      customData: String(src.customData || ''),
      nics: (src.nics || []).map((n, i) => ({
        ...n,
        id: uid(),
        name: String(n.name || `nic${i+1}`)
      })),
      disks: (src.disks || []).map(d => ({ ...d }))
    };

    vms.push(clone);
    active = vms.length - 1;
    render();
  };

  $('removeVmBtn').onclick = () => {
    if (vms.length <= 1) return;
    vms.splice(active, 1);
    active = Math.max(0, active - 1);
    render();
  };

  $('addNicBtn').onclick = () => {
    const vm = vms[active];
    ensureNic(vm);
    if ((vm.nics || []).length >= maxNicsFor(vm)) {
      showToast('NIC limit reached', `VM size '${vm.size}' supports up to ${maxNicsFor(vm)} NIC(s).`);
      return;
    }
    const nic = defaultNic(vm.nics.length);
    nic.name = nextDefaultNicName(vm);
    vm.nics.push(nic);
    renderNics(vm);
    updateNicDiskButtons(vm);
    updateOutput();
  };
  $('addDiskBtn').onclick = () => {
    const vm = vms[active];
    vm.disks = vm.disks || [];
    if ((vm.disks || []).length >= maxDataDisksFor(vm)) {
      showToast('Data disk limit reached', `VM size '${vm.size}' supports up to ${maxDataDisksFor(vm)} data disk(s).`);
      return;
    }
    vm.disks.push({ sizeGB: LIMITS.DEFAULT_DATA_DISK_GB, sku: defaultDiskSkuFor(vm) });
    renderDisks(vm);
    updateNicDiskButtons(vm);
    updateOutput();
  };

  $('vmName').oninput = (e) => {
    vms[active].name = e.target.value;
    renderTabs();
    updateNicNameConstraints(vms[active]);
    const nameErr = $('vmNameError');
    if (nameErr) {
      nameErr.textContent = vmNameErrorAt(active);
    }
    updateOutput();
  };
  $('vmCustomData').oninput = (e) => {
    vms[active].customData = e.target.value || '';
    updateOutput();
  };
  $('vmRebootRequired').onchange = (e) => {
    vms[active].rebootRequired = !!e.target.checked;
    updateOutput();
  };
  $('vmSize').onchange = (e) => {
  const vm = vms[active];
  const prevGen = vm.gen;
  const prevCtl = vm.diskControllerType;
  const prevImageKey = vm.imageKey;
  vm.size = e.target.value;

  // Size may constrain generation + controller.
  const gens = allowedGenerationsFor(vm);
  if (!gens.includes(vm.gen)) vm.gen = gens[0];
  const ctls = allowedControllersFor(vm);
  if (!ctls.includes(vm.diskControllerType)) vm.diskControllerType = ctls[0];

  // Image may be forced by architecture/gen/controller filters.
  const imgs = filterImagesFor(vm);
  if (!imgs.find(i => i.key === vm.imageKey)) vm.imageKey = imgs[0] ? imgs[0].key : '';
  const changedSkus = normalizeDataDiskSkus(vm);

  if (prevGen !== vm.gen && prevCtl !== vm.diskControllerType) {
    showToast('Adjusted VM settings', `Size changed. Gen '${prevGen}''${vm.gen}', Controller '${prevCtl}''${vm.diskControllerType}'.`);
  } else if (prevGen !== vm.gen) {
    showToast('Adjusted VM generation', `Size changed. Gen '${prevGen}' isn't supported, switched to '${vm.gen}'.`);
  } else if (prevCtl !== vm.diskControllerType) {
    showToast('Adjusted disk controller', `Size changed. Controller '${prevCtl}' isn't supported, switched to '${vm.diskControllerType}'.`);
  }

  if (prevImageKey !== vm.imageKey) {
    const prevLabel = (imageByKey(prevImageKey) || {}).label || prevImageKey || 'previous image';
    const nextLabel = (imageByKey(vm.imageKey) || {}).label || vm.imageKey || 'no image';
    showToast('Adjusted OS image', `Size architecture/capabilities changed. '${prevLabel}'  '${nextLabel}'.`);
  }

  if (changedSkus > 0) {
    showToast('Adjusted data disk SKU', `Size changed. ${changedSkus} data disk(s) were switched to supported SKU values.`);
  }

  const nicOverflow = (vm.nics || []).length - maxNicsFor(vm);
  if (nicOverflow > 0) {
    showToast('NIC count exceeds size limit', `Size '${vm.size}' supports up to ${maxNicsFor(vm)} NIC(s). Remove ${nicOverflow} NIC(s).`);
  }

  const diskOverflow = (vm.disks || []).length - maxDataDisksFor(vm);
  if (diskOverflow > 0) {
    showToast('Data disk count exceeds size limit', `Size '${vm.size}' supports up to ${maxDataDisksFor(vm)} data disk(s). Remove ${diskOverflow} disk(s).`);
  }

  renderVmSelects(vm);
  renderHints(vm);
  renderNics(vm);
  renderDisks(vm);
  updateNicDiskButtons(vm);
  updateOutput();
};
  $('vmGen').onchange = (e) => {
  const vm = vms[active];
  const prevCtl = vm.diskControllerType;
  const prevImageKey = vm.imageKey;
  vm.gen = e.target.value;

  // If controller is no longer allowed for selected generation, auto-fix and explain.
  const allowed = allowedControllersFor(vm);
  if (!allowed.includes(vm.diskControllerType)) {
    vm.diskControllerType = allowed[0];
    showToast('Adjusted disk controller', `Selected ${vm.gen}. Controller '${prevCtl}' isn't supported, switched to '${vm.diskControllerType}'.`);
  }

  const imgs = filterImagesFor(vm);
  if (!imgs.find(i => i.key === vm.imageKey)) {
    vm.imageKey = imgs[0] ? imgs[0].key : '';
    const prevLabel = (imageByKey(prevImageKey) || {}).label || prevImageKey || 'previous image';
    const nextLabel = (imageByKey(vm.imageKey) || {}).label || vm.imageKey || 'no image';
    showToast('Adjusted OS image', `Generation/controller changed. '${prevLabel}'  '${nextLabel}'.`);
  }

  populateControllerSelect(vm);
  populateImageSelect(vm);
  renderHints(vm);
  updateOutput();
};
  $('vmImage').onchange = (e) => { vms[active].imageKey = e.target.value; updateOutput(); };
  $('vmPublisher').onchange = (e) => {
    const vm = vms[active];
    const prevImageKey = vm.imageKey;
    vm.publisherFilter = e.target.value || '';
    const imgs = filterImagesFor(vm);
    if (!imgs.find(i => i.key === vm.imageKey)) vm.imageKey = imgs[0] ? imgs[0].key : '';
    if (prevImageKey !== vm.imageKey) {
      const prevLabel = (imageByKey(prevImageKey) || {}).label || prevImageKey || 'previous image';
      const nextLabel = (imageByKey(vm.imageKey) || {}).label || vm.imageKey || 'no image';
      showToast('Adjusted OS image', `Publisher filter changed. '${prevLabel}'  '${nextLabel}'.`);
    }
    populateImageSelect(vm);
    updateOutput();
  };
  $('diskController').onchange = (e) => {
    const vm = vms[active];
    const prevImageKey = vm.imageKey;
    vm.diskControllerType = e.target.value;

    const imgs = filterImagesFor(vm);
    if (!imgs.find(i => i.key === vm.imageKey)) {
      vm.imageKey = imgs[0] ? imgs[0].key : '';
      const prevLabel = (imageByKey(prevImageKey) || {}).label || prevImageKey || 'previous image';
      const nextLabel = (imageByKey(vm.imageKey) || {}).label || vm.imageKey || 'no image';
      showToast('Adjusted OS image', `Disk controller changed. '${prevLabel}'  '${nextLabel}'.`);
    }

    populateImageSelect(vm);
    renderHints(vm);
    updateOutput();
  };

  $('copyBtn').onclick = async () => {
    try {
      await navigator.clipboard.writeText($('output').value);
      $('copyBtn').textContent = 'Copied!';
      setTimeout(() => $('copyBtn').textContent = 'Copy', LIMITS.COPY_FEEDBACK_MS);
    } catch (e) {
      alert('Clipboard copy failed. You can manually copy from the textarea.');
    }
  };

  $('deployPortalBtn').onclick = async () => {
    try {
      await navigator.clipboard.writeText($('output').value);
      const url = 'https://portal.azure.com/#create/Microsoft.Template';
      const btn = $('deployPortalBtn');
      const originalText = btn ? btn.textContent : 'Copy + Open Portal';

      if (btn) {
        btn.disabled = true;
        btn.textContent = 'Opening in 5s...';
      }

      showDeployFlow('ARM JSON copied to clipboard. In Custom deployment, choose "Build your own template in the editor", then paste the JSON from clipboard. If the portal does not open, allow pop-up windows for this page.', LIMITS.DEPLOY_COUNTDOWN_S);

      setTimeout(() => {
        window.open(url, '_blank', 'noopener');
        if (btn) {
          btn.textContent = originalText;
          btn.disabled = false;
        }
      }, LIMITS.DEPLOY_COUNTDOWN_S * 1000);
    } catch (e) {
      alert('Unable to copy JSON and open Azure portal automatically. Please copy manually, then open https://portal.azure.com/#create/Microsoft.Template');
    }
  };

  $('downloadBtn').onclick = () => {
    const blob = new Blob([$('output').value], { type: 'application/json;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'azuredeploy.json';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  $('importBtn').onclick = () => { $('importFileInput').click(); };
  $('importFileInput').onchange = (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      importFromArmJson(reader.result);
      // Reset input so re-importing the same file triggers onchange again
      $('importFileInput').value = '';
    };
    reader.onerror = () => showToast('Import failed', 'Could not read the selected file.');
    reader.readAsText(file);
  };

  $('helpBtn').onclick = (e) => {
    e.stopPropagation();
    const balloon = $('helpBalloon');
    if (!balloon) return;
    const nextShow = !balloon.classList.contains('show');
    balloon.classList.toggle('show', nextShow);
    balloon.setAttribute('aria-hidden', nextShow ? 'false' : 'true');
  };

  document.addEventListener('click', (e) => {
    const balloon = $('helpBalloon');
    const wrap = document.querySelector('.help-wrap');
    if (!balloon || !wrap) return;
    if (!wrap.contains(e.target)) {
      balloon.classList.remove('show');
      balloon.setAttribute('aria-hidden', 'true');
    }
  });

  document.addEventListener('keydown', (e) => {
    if (e.key !== 'Escape') return;
    // Close filter panel if open (focus-trap handler above takes priority when focus is inside)
    if (filterPanelIsOpen()) { closeFilterPanel(true); }
    const balloon = $('helpBalloon');
    if (!balloon) return;
    balloon.classList.remove('show');
    balloon.setAttribute('aria-hidden', 'true');
  });

  render();
</script>

<div id="toast" class="toast" aria-live="polite" aria-atomic="true">
  <div class="title" id="toastTitle"></div>
  <div class="msg" id="toastMsg"></div>
</div>

</body>
</html>
