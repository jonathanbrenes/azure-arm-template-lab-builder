# Linux ARM Template UI

Web-based ARM template builder for multi-VM Linux lab environments on Azure.

## What’s Available Today

- Multi-VM builder with per-VM configuration for:
  - VM name, size, generation, publisher, image, and disk controller
  - NICs (including accelerated networking and public IP toggle)
  - Data disks (size + SKU)
  - Custom data and optional reboot flag
- Compatibility-aware selection logic:
  - Size constrains generation, disk controller, and image compatibility
  - Architecture/generation/controller-aware image filtering
  - Optional publisher filter
- VM size filter panel with 9 dimensions:
  - Family, architecture, generation, controller, disk SKU support,
    accelerated networking mode, ephemeral OS disk support,
    minimum max NICs, minimum max data disks
- Shared data disk workflow:
  - Create shared disks
  - Attach shared disks across VMs (up to 2 attachments)
  - Cross-VM SKU/size synchronization for attached shared disks
- Optional storage resources from Extra options:
  - SMB Azure Files
  - NFS Azure Files
  - Share-name validation and summary rendering
- Custom inbound NSG rules from Extra options:
  - Protocol: TCP/UDP
  - Port: single port or range
  - Source: AzureCloud/Internet
- ARM template generation with:
  - Shared network resources (VNet, subnet, NSG)
  - Per-VM NICs, optional PIPs, and VM resources
  - Optional SMB/NFS private endpoint + DNS resources
  - Ultra/PremiumV2/shared-disk zone-aware placement when required
  - Automatic `/etc/hosts` synchronization on deployed VMs so each server includes hostname/IP entries for all VMs created by the same ARM template
- Import ARM JSON:
  - Reconstructs VMs, NIC settings, disks, SMB/NFS settings, and custom NSG rules
  - Skips unsupported or unmapped entries with import summary feedback
- Output actions:
  - Copy
  - Copy + Portal
  - Download

## New in Current Local Version

Compared to the `main` hosted copy, your current local UI includes an expanded JSON workspace:

- Maximize/minimize JSON editor using corner controls (`⛶` and `□`)
- Full-screen JSON view (`Expanded ARM JSON`)
- Mirrored output actions inside expanded view:
  - Copy
  - Copy + Portal
  - Download
  - Import JSON

## UI Behavior

- Validation prevents output actions until required fields/rules are satisfied.
- Toast notifications provide immediate feedback for automatic adjustments.
- VM summary and storage summary are rendered below generated JSON.
- State is persisted in `localStorage` and restored on reload.
- Generated templates configure `/etc/hosts` on each deployed VM with hostname/IP entries for all VMs created in the same template deployment.

## Accessibility

- VM tabs support keyboard navigation (Left/Right/Home/End).
- Filter panel is focus-trapped and supports Escape to close.
- Filter result count is announced via aria-live region.

## Import Behavior

`Import JSON` reads ARM resources and maps them back into the UI model:

- `Microsoft.Compute/virtualMachines`
- `Microsoft.Network/networkInterfaces`
- `Microsoft.Network/publicIPAddresses`
- `Microsoft.Network/networkSecurityGroups`
- `Microsoft.Storage/storageAccounts/fileServices/shares`

Imported custom data is intentionally cleared (reverse-decoding to original source script is not deterministic).

When a template generated by this tool is deployed, `/etc/hosts` is populated on each VM with hostname/IP mappings for all VMs in that same deployment.

## Build and Outputs

Generated artifacts:

- `index.static.html` (single-file static build)
- `index.html` (split entry HTML that loads external JS/CSS assets)
- `styles.css` (UI styles)
- `app.js` (UI/state/event logic)
- `data/image-options.js`
- `data/size-options.js`
- `data/arm-generator.js`

## Split File Architecture

- The app now ships in two public formats:
  - `index.static.html`: standalone single-file experience
  - `index.html`: split experience using external assets
- In split mode, `index.html` references:
  - `styles.css`
  - `data/image-options.js`
  - `data/size-options.js`
  - `data/arm-generator.js`
  - `app.js`
- ARM generation logic is intentionally separated into `data/arm-generator.js`, while interaction/state logic lives in `app.js`.

## Key Functions Implemented

- `generateArmTemplate(vms, storageOptions)`
  - Produces ARM JSON from current VM + storage configuration.
- `updateOutput()`
  - Runs validation and refreshes generated JSON/output actions.
- `importFromArmJson(jsonText)`
  - Imports compatible ARM templates into the current UI model.
- `renderStorageSection()` and `renderStorageSummary()`
  - Drive storage overlay controls and rendered storage summary.
- `renderCustomNsgRules()`
  - Manages custom NSG rule list UI and state updates.
- `openJsonFlowWindow()` and `closeJsonFlowWindow()`
  - Control expanded JSON workspace open/close behavior.
- `bootstrapApp()`
  - Starts the app safely after page load in split/static delivery.

## Helper Scripts

- `urn-to-imageoption.sh` — generates `imageOptions` entries from image URNs
- `sku-to-sizeoption.sh` — generates `sizeOptions` entries from VM SKUs

## Project Files

- `index.static.html` — generated static artifact
- `index.html` / `styles.css` / `app.js` / `data/*` — generated split artifacts
- `README.md` — project documentation
